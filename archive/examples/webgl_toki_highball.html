<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - Toki Japanese Highball</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500&family=Cormorant+Garamond:wght@400;500&display=swap');

			body {
				font-family: 'Noto Sans JP', sans-serif;
				background: #87CEEB;
			}

			#info {
				background: rgba(20, 40, 60, 0.9);
				border: 1px solid rgba(100, 160, 200, 0.4);
				backdrop-filter: blur(12px);
			}

			#info .title-wrapper span {
				color: #000000;
				font-family: 'Cormorant Garamond', serif;
				font-weight: 500;
				letter-spacing: 1px;
			}

			#info .title-wrapper a {
				color: #ffffff;
			}

			#info small {
				color: rgba(255, 255, 255, 0.7);
			}

			#drinkControls {
				position: fixed;
				bottom: 20px;
				left: 20px;
				background: rgba(20, 40, 60, 0.92);
				border: 1px solid rgba(100, 160, 200, 0.3);
				border-radius: 16px;
				padding: 20px 24px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 13px;
				backdrop-filter: blur(12px);
				z-index: 100;
				min-width: 220px;
				display: none;
			}

			#audioControls {
				position: fixed;
				top: 20px;
				right: 20px;
				background: rgba(20, 40, 60, 0.92);
				border: 1px solid rgba(100, 160, 200, 0.3);
				border-radius: 16px;
				padding: 16px 20px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 13px;
				backdrop-filter: blur(12px);
				z-index: 100;
				display: flex;
				align-items: center;
				gap: 12px;
			}

			#drinkControls h3 {
				margin: 0 0 16px 0;
				font-size: 15px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
				font-family: 'Cormorant Garamond', serif;
				text-transform: uppercase;
			}

			.control-row {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 14px;
			}

			.control-row:last-child {
				margin-bottom: 0;
			}

			.control-row label {
				color: rgba(255, 255, 255, 0.8);
				font-size: 12px;
				min-width: 70px;
			}

			.control-row .controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			#drinkControls button {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.4);
				color: #7ec8e8;
				padding: 6px 12px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 12px;
				font-weight: 500;
				transition: all 0.2s ease;
				font-family: inherit;
			}

			#drinkControls button:hover {
				background: rgba(126, 200, 232, 0.25);
				border-color: rgba(126, 200, 232, 0.6);
			}

			#drinkControls button:active {
				transform: scale(0.96);
			}

			#drinkControls button.active {
				background: rgba(126, 200, 232, 0.35);
				border-color: #7ec8e8;
			}

			#fizzValue {
				min-width: 32px;
				text-align: center;
				font-weight: 500;
				color: #ffffff;
			}

			.slider-control {
				width: 70px;
				height: 4px;
				-webkit-appearance: none;
				appearance: none;
				background: rgba(126, 200, 232, 0.25);
				border-radius: 2px;
				outline: none;
				cursor: pointer;
			}

			.slider-control::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border-radius: 50%;
				cursor: pointer;
				transition: transform 0.15s ease;
			}

			.slider-control::-webkit-slider-thumb:hover {
				transform: scale(1.15);
			}

			.slider-control::-moz-range-thumb {
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border: none;
				border-radius: 50%;
				cursor: pointer;
			}

			.audio-toggle {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.4);
				color: #7ec8e8;
				width: 36px;
				height: 36px;
				border-radius: 50%;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.2s ease;
				padding: 0;
				flex-shrink: 0;
			}

			.audio-toggle:hover {
				background: rgba(126, 200, 232, 0.25);
				border-color: rgba(126, 200, 232, 0.6);
				transform: scale(1.05);
			}

			.audio-toggle:active {
				transform: scale(0.95);
			}

			.audio-toggle.active {
				background: rgba(126, 200, 232, 0.35);
				border-color: #7ec8e8;
			}

			.audio-toggle svg {
				width: 16px;
				height: 16px;
				stroke: #7ec8e8;
			}

			#audioControls .volume-controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			#audioControls .slider-control {
				width: 80px;
			}

			#audioControls #volumeValue {
				min-width: 35px;
				text-align: center;
				font-weight: 500;
				color: #ffffff;
				font-size: 12px;
			}

			#brandLabel {
				position: fixed;
				bottom: 20px;
				right: 20px;
				font-family: 'Cormorant Garamond', serif;
				font-size: 24px;
				color: rgba(20, 60, 90, 0.5);
				letter-spacing: 3px;
				text-transform: uppercase;
				writing-mode: vertical-rl;
				text-orientation: mixed;
				z-index: 100;
			}

			/* Hotspot Info Panel Styles */
			.hotspot-panel {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%) scale(0.9);
				background: rgba(20, 40, 60, 0.96);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 20px;
				padding: 32px 40px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				backdrop-filter: blur(16px);
				z-index: 200;
				max-width: 420px;
				width: 90%;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
				box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
			}

			.hotspot-panel.active {
				opacity: 1;
				visibility: visible;
				transform: translate(-50%, -50%) scale(1);
			}

			.hotspot-panel-header {
				display: flex;
				justify-content: space-between;
				align-items: flex-start;
				margin-bottom: 20px;
			}

			.hotspot-panel h2 {
				margin: 0;
				font-family: 'Cormorant Garamond', serif;
				font-size: 26px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
			}

			.hotspot-panel-close {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.3);
				color: #7ec8e8;
				width: 36px;
				height: 36px;
				border-radius: 50%;
				cursor: pointer;
				font-size: 20px;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.2s ease;
				flex-shrink: 0;
				margin-left: 16px;
			}

			.hotspot-panel-close:hover {
				background: rgba(126, 200, 232, 0.3);
				transform: scale(1.1);
			}

			.hotspot-panel p {
				margin: 0 0 16px 0;
				font-size: 14px;
				line-height: 1.7;
				color: rgba(255, 255, 255, 0.85);
			}

			.hotspot-panel p:last-child {
				margin-bottom: 0;
			}

			.hotspot-panel .highlight {
				color: #dbb85c;
				font-weight: 500;
			}

			.hotspot-panel video {
				width: 100%;
				border-radius: 12px;
				margin-top: 16px;
				background: #000;
			}

			.hotspot-panel .video-placeholder {
				width: 100%;
				aspect-ratio: 16/9;
				background: linear-gradient(135deg, rgba(126, 200, 232, 0.15), rgba(219, 184, 92, 0.15));
				border-radius: 12px;
				margin-top: 16px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				border: 1px dashed rgba(126, 200, 232, 0.3);
			}

			.hotspot-panel .video-placeholder svg {
				width: 48px;
				height: 48px;
				fill: rgba(126, 200, 232, 0.6);
				margin-bottom: 12px;
			}

			.hotspot-panel .video-placeholder span {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.5);
			}

			.hotspot-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.5);
				z-index: 150;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s ease;
			}

			.hotspot-overlay.active {
				opacity: 1;
				visibility: visible;
			}

			/* Hotspot Label Tooltips */
			.hotspot-label {
				position: fixed;
				background: rgba(20, 40, 60, 0.9);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 8px;
				padding: 8px 14px;
				color: #7ec8e8;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 12px;
				font-weight: 500;
				pointer-events: none;
				z-index: 120;
				opacity: 0;
				transform: translateY(8px);
				transition: all 0.25s ease;
				white-space: nowrap;
				backdrop-filter: blur(8px);
			}

			.hotspot-label.visible {
				opacity: 1;
				transform: translateY(0);
			}

			#overlay {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(20, 40, 60, 0.95);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 16px;
				padding: 32px 40px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				text-align: center;
				backdrop-filter: blur(12px);
				z-index: 200;
				max-width: 400px;
			}

			#overlay p {
				margin: 0 0 20px 0;
				font-size: 14px;
				color: rgba(255, 255, 255, 0.8);
			}

			#overlay button {
				background: linear-gradient(135deg, #7ec8e8 0%, #5aa8c4 100%);
				color: #1a3a4a;
				border: none;
				padding: 12px 32px;
				border-radius: 8px;
				font-size: 14px;
				font-weight: 600;
				cursor: pointer;
				transition: all 0.2s ease;
				font-family: inherit;
			}

			#overlay button:hover {
				background: linear-gradient(135deg, #8dd4f0 0%, #6bb8d4 100%);
				transform: translateY(-2px);
			}
		</style>
	</head>
	<body>

			<!-- <div id="info">

			<div class="title-wrapper">
				<span>Toki Japanese Highball</span>
			</div>

			<small>
				Tap hotspots to learn more. Drag to orbit.
			</small>
		</div> -->

		<div id="drinkControls" role="region" aria-label="Drink controls">
			<h3>Highball Settings</h3>
			<div class="control-row">
				<label for="fizzSlider">Carbonation</label>
				<div class="controls">
					<input type="range" id="fizzSlider" class="slider-control" min="0" max="600" step="10" value="600" aria-label="Fizz intensity">
					<span id="fizzValue">600%</span>
				</div>
			</div>
		</div>

		<div id="audioControls" role="region" aria-label="Audio controls">
			<button id="audioToggle" class="audio-toggle" aria-label="Toggle background music" tabindex="0">
				<svg id="playIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
					<polygon points="5 3 19 12 5 21 5 3"></polygon>
				</svg>
				<svg id="pauseIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
					<rect x="6" y="4" width="4" height="16"></rect>
					<rect x="14" y="4" width="4" height="16"></rect>
				</svg>
			</button>
			<div class="volume-controls">
				<input type="range" id="volumeSlider" class="slider-control" min="0" max="100" step="1" value="30" aria-label="Volume">
				<span id="volumeValue">30%</span>
			</div>
		</div>

		<!-- Background Audio -->
		<audio id="backgroundAudio" loop preload="auto">
			<source src="audio/japa-jazz.mp3" type="audio/mpeg">
		</audio>

		<div id="brandLabel">TOKI</div>

		<div id="overlay" aria-live="polite">
			<p>Tap to enable motion controls or keep using touch.</p>
			<button id="enableMotionButton" aria-label="Enable motion controls">Enable motion</button>
		</div>

		<!-- Hotspot Overlay -->
		<div id="hotspotOverlay" class="hotspot-overlay" role="presentation"></div>

		<!-- Hotspot Info Panels -->
		<div id="panelWhisky" class="hotspot-panel" role="dialog" aria-labelledby="panelWhiskyTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelWhiskyTitle">Suntory Toki</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				<span class="highlight">Toki</span> means "time" in Japanese, representing the harmony of old and new. 
				This blended Japanese whisky combines malt from Hakushu and Yamazaki distilleries with 
				grain whisky from Chita.
			</p>
			<p>
				Silky with a subtle sweetness, it's the perfect base for a refreshing Highball—Japan's 
				most popular way to enjoy whisky.
			</p>
		</div>

		<div id="panelIce" class="hotspot-panel" role="dialog" aria-labelledby="panelIceTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelIceTitle">The Perfect Ice</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				In Japan, ice is an art form. Large, <span class="highlight">crystal-clear cubes</span> are essential 
				for the perfect Highball—they melt slowly, keeping your drink cold without over-diluting.
			</p>
			<p>
				The best Highball bars in Tokyo hand-carve their ice from massive blocks, ensuring purity 
				and the ideal melting rate.
			</p>
		</div>

		<div id="panelGlass" class="hotspot-panel" role="dialog" aria-labelledby="panelGlassTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelGlassTitle">Highball Glass</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				The tall, slender <span class="highlight">Collins glass</span> is traditional for Japanese Highballs. 
				Its narrow profile preserves carbonation and creates an elegant presentation.
			</p>
			<p>
				Many Japanese bars freeze their glasses beforehand, creating a frosty exterior that 
				keeps your Highball perfectly chilled from the first sip to the last.
			</p>
		</div>

		<div id="panelVideo" class="hotspot-panel" role="dialog" aria-labelledby="panelVideoTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelVideoTitle">The Ritual</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				Watch how Japanese bartenders craft the <span class="highlight">perfect Toki Highball</span>—a ritual 
				of precision and care.
			</p>
			<div class="video-placeholder">
				<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
					<path d="M8 5v14l11-7z"/>
				</svg>
				<span>Video content placeholder</span>
			</div>
		</div>

		<!-- Hotspot Label Tooltip -->
		<div id="hotspotLabel" class="hotspot-label"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let renderer, scene, camera, controls;
			let liquidSurface, liquidBody;
			let liquidUniforms;
			let raycaster;
			let waterPlane;
			let glassOuter, glassInner;
			const mouse = new THREE.Vector2();
			let backgroundTexture = null;
			let motionOverlay = null;
			let enableMotionButton = null;

			// Hotspot system
			const hotspots = [];
			let activePanel = null;
			const hotspotLabel = document.getElementById('hotspotLabel');
			const hotspotOverlay = document.getElementById('hotspotOverlay');

			// Bubble system
			let bubbleGeometry, bubbleMaterial;
			let bubbleInstances = [];
			const MAX_BUBBLES = 500;
			let bubbleMesh;

			// Orange slice
			let orangeSlice;
			let orangeSliceVisible = true;

			// Ice cubes (simple floating objects)
			const iceObjects = [];
			const iceConfig = {
				quantity: 2,
				maxQuantity: 4,
				baseSize: 0.12,
				sizeMultiplier: 3.75,
			};

			// Fizz configuration
			let fizzIntensity = 6.0;

			// Time tracking
			let elapsedTime = 0;

			// Highball glass dimensio.ns (taller and slender)
			const GLASS_RADIUS = 0.85;
			const GLASS_HEIGHT = 2.8;
			const GLASS_THICKNESS = 0.04;

			// Liquid configuration
			const LIQUID_RADIUS = GLASS_RADIUS - GLASS_THICKNESS - 0.02;
			const LIQUID_HEIGHT = 2.2;
			const LIQUID_BASE_Y = 0.1;
			const LIQUID_SURFACE_Y = LIQUID_BASE_Y + LIQUID_HEIGHT;

			// Toki Highball golden amber color (20% darker)
			const LIQUID_COLOR = 0xaf934a;
			const LIQUID_DEEP_COLOR = 0xa18033;

			const motionState = {
				enabled: false,
				available: false,
				tilt: new THREE.Vector2(),
				targetTilt: new THREE.Vector2(),
				ripplePos: new THREE.Vector2(10000, 10000),
				rippleStrength: 0,
				lastUpdate: 0,
			};

			// Background image cover scaling function
			function updateBackgroundCover() {

				if (!backgroundTexture || !backgroundTexture.image) return;

				const canvasAspect = window.innerWidth / window.innerHeight;
				const imageAspect = backgroundTexture.image.width / backgroundTexture.image.height;

				// Calculate scale to cover (image fills viewport, maintaining aspect ratio)
				let scaleX = 1;
				let scaleY = 1;
				let offsetX = 0;
				let offsetY = 0;

				if (canvasAspect > imageAspect) {
					// Canvas is wider than image - scale image up to fill canvas height, crop sides
					scaleX = canvasAspect / imageAspect;
					scaleY = 1;
					offsetX = (1 - scaleX) / 2;
					offsetY = 0;
				} else {
					// Canvas is taller than image - scale image up to fill canvas width, crop top/bottom
					scaleX = 1;
					scaleY = imageAspect / canvasAspect;
					offsetX = 0;
					offsetY = (1 - scaleY) / 2;
				}

				backgroundTexture.matrixAutoUpdate = false;
				backgroundTexture.matrix.setUvTransform(offsetX, offsetY, scaleX, scaleY, 0, 0.5, 0.5);
				backgroundTexture.needsUpdate = true;

			}


			init();

			function createIceMaterial() {

				// Use MeshStandardMaterial instead of transmission-based material
				// to avoid masking/transparency sorting issues
				return new THREE.MeshStandardMaterial({
					color: 0xd8e4f0,
					metalness: 0.1,
					roughness: 0.2,
					transparent: true,
					opacity: 0.75,
					envMapIntensity: 0.8,
					side: THREE.FrontSide,
					depthWrite: true,
				});

			}

			function createIceMesh(size) {

				// Rectangular ice cube typical for highballs
				const geometry = new THREE.BoxGeometry(size * 1.8, size * 2.2, size * 1.8);
				const material = createIceMaterial();
				const mesh = new THREE.Mesh(geometry, material);
				mesh.renderOrder = 3;
				mesh.userData.baseSize = size;

				// Add inner frosted core for realism
				const innerGeometry = new THREE.BoxGeometry(size * 1.4, size * 1.8, size * 1.4);
				const innerMaterial = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					metalness: 0.0,
					roughness: 0.9,
					transparent: true,
					opacity: 0.35,
					side: THREE.FrontSide,
				});
				const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
				innerMesh.renderOrder = 2;
				mesh.add(innerMesh);

				return mesh;

			}

			function getCurrentIceSize() {

				return iceConfig.baseSize * iceConfig.sizeMultiplier;

			}

			function updateAllIceSizes() {

				const newSize = getCurrentIceSize();

				for (const ice of iceObjects) {

					const scale = newSize / ice.mesh.userData.baseSize;
					ice.mesh.scale.set(scale, scale, scale);

				}

			}

			function getIceHeight(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Ice height is 2.2 * size * scale
				return size * 2.2 * scale * 0.5;

			}

			function findNonOverlappingPosition(size, iceIndex) {

				const iceHeight = size * 2.2;
				
				// For 2 stacked ice cubes - deterministic positioning
				if (iceIndex === 0) {

					// First (top) ice cube - breaks the surface
					// Positioned at center, 30% submerged
					return { 
						x: 0, 
						z: 0, 
						y: LIQUID_SURFACE_Y - iceHeight * 0.35
					};

				} else {

					// Second (bottom) ice cube - stacked below the first
					// Positioned directly under the first cube
					const topIce = iceObjects[0];
					const stackY = topIce.baseY - iceHeight - 0.02; // Stack below with small gap
					
					return { 
						x: topIce.baseX + (Math.random() - 0.5) * 0.05, // Tiny offset for realism
						z: topIce.baseZ + (Math.random() - 0.5) * 0.05, 
						y: Math.max(stackY, LIQUID_BASE_Y + iceHeight * 0.5 + 0.1) // Don't go below glass bottom
					};

				}

			}

			function spawnIce() {

				if (iceObjects.length >= iceConfig.maxQuantity) return;

				const size = getCurrentIceSize();
				const iceIndex = iceObjects.length;
				const position = findNonOverlappingPosition(size, iceIndex);

				const mesh = createIceMesh(size);

				// First ice cube is the "surface" ice
				const isFirstIce = iceIndex === 0;

				// Each ice cube gets unique animation parameters
				const iceData = {
					mesh,
					baseX: position.x,
					baseY: position.y,
					baseZ: position.z,
					targetY: position.y,
					isFloater: isFirstIce,
					velocityY: 0,
					phaseX: Math.random() * Math.PI * 2,
					phaseZ: Math.random() * Math.PI * 2,
					phaseY: Math.random() * Math.PI * 2,
					rotationSpeed: (Math.random() - 0.5) * 0.3,
					bobSpeed: 0.8 + Math.random() * 0.4,
					bobAmount: isFirstIce ? 0.02 : 0.01,
					driftAmount: 0.01 + Math.random() * 0.01,
				};

				mesh.position.set(
					iceData.baseX,
					iceData.baseY,
					iceData.baseZ
				);

				mesh.rotation.set(
					Math.random() * 0.3,
					Math.random() * Math.PI * 2,
					Math.random() * 0.3
				);

				scene.add(mesh);
				iceObjects.push(iceData);

			}

			function removeIce() {

				if (iceObjects.length === 0) return;

				const ice = iceObjects.pop();
				scene.remove(ice.mesh);
				ice.mesh.geometry.dispose();
				ice.mesh.material.dispose();

			}


			function getIceCollisionRadius(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Use the larger dimension (1.8 * size * scale) as collision radius
				return size * 1.8 * scale * 0.5;

			}

			function resolveIceCollisions() {

				const size = getCurrentIceSize();
				const iceHeight = size * 2.2;
				const minY = LIQUID_BASE_Y + iceHeight * 0.5 + 0.05;
				const boundsRadius = LIQUID_RADIUS - size * 0.8;

				// For 2 stacked cubes - maintain vertical alignment
				if (iceObjects.length === 2) {

					const topIce = iceObjects[0];  // First ice (floater at top)
					const bottomIce = iceObjects[1];  // Second ice (below)

					// Keep top ice at surface level
					const topTargetY = LIQUID_SURFACE_Y - iceHeight * 0.35;
					topIce.baseY += (topTargetY - topIce.baseY) * 0.1;

					// Keep bottom ice stacked below top ice
					const bottomTargetY = topIce.baseY - iceHeight - 0.02;
					const clampedBottomY = Math.max(bottomTargetY, minY);
					bottomIce.baseY += (clampedBottomY - bottomIce.baseY) * 0.1;

					// Keep bottom ice horizontally aligned with top (slight offset for realism)
					bottomIce.baseX += (topIce.baseX - bottomIce.baseX) * 0.05;
					bottomIce.baseZ += (topIce.baseZ - bottomIce.baseZ) * 0.05;

				}

				// Apply bounds constraints for all ice
				for (const ice of iceObjects) {

					// Keep within glass bounds horizontally
					const currentDist = Math.sqrt(ice.baseX * ice.baseX + ice.baseZ * ice.baseZ);
					if (currentDist > boundsRadius) {

						const scale = boundsRadius / currentDist;
						ice.baseX *= scale;
						ice.baseZ *= scale;

					}

					// Clamp Y range
					const maxY = ice.isFloater 
						? LIQUID_SURFACE_Y - iceHeight * 0.25 
						: LIQUID_SURFACE_Y - iceHeight * 0.6;
					
					if (ice.baseY > maxY) ice.baseY = maxY;
					if (ice.baseY < minY) ice.baseY = minY;

				}

			}

			function updateIceAnimation(time) {

				const size = getCurrentIceSize();
				const boundsRadius = LIQUID_RADIUS - size * 1.0;

				// Resolve collisions (iterations are inside the function)
				resolveIceCollisions();

				for (const ice of iceObjects) {

					// Gentle bobbing motion - stronger for floater
					const bobY = Math.sin(time * ice.bobSpeed + ice.phaseY) * ice.bobAmount;

					// Slight drift in X and Z
					const driftX = Math.sin(time * 0.3 + ice.phaseX) * ice.driftAmount;
					const driftZ = Math.cos(time * 0.25 + ice.phaseZ) * ice.driftAmount;

					// Apply position from base + drift
					let newX = ice.baseX + driftX;
					let newZ = ice.baseZ + driftZ;

					// Final boundary check
					const dist = Math.sqrt(newX * newX + newZ * newZ);

					if (dist > boundsRadius) {

						const boundsScale = boundsRadius / dist;
						newX *= boundsScale;
						newZ *= boundsScale;

					}

					ice.mesh.position.x = newX;
					ice.mesh.position.y = ice.baseY + bobY;
					ice.mesh.position.z = newZ;

					// Gentle rotation
					ice.mesh.rotation.y += ice.rotationSpeed * 0.016;
					ice.mesh.rotation.x = Math.sin(time * 0.5 + ice.phaseX) * 0.06;
					ice.mesh.rotation.z = Math.cos(time * 0.4 + ice.phaseZ) * 0.06;

				}

			}

			// Orange peel creation (single strip peel)
			function createOrangeSlice() {

				const group = new THREE.Group();

				// Peel dimensions - shorter strip (half length)
				const peelLength = 1.2;
				const peelWidth = 0.18;
				const peelThickness = 0.035;
				const curveSegments = 16;

				// Create a curved path for the peel - gentle S-curve
				const curve = new THREE.CatmullRomCurve3([
					new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(0.06, peelLength * 0.3, 0.03),
					new THREE.Vector3(-0.04, peelLength * 0.6, 0.05),
					new THREE.Vector3(0.02, peelLength, 0),
				]);

				// Create custom peel geometry by extruding along curve
				const peelShape = new THREE.Shape();
				peelShape.moveTo(-peelWidth / 2, 0);
				peelShape.lineTo(peelWidth / 2, 0);
				peelShape.lineTo(peelWidth / 2, peelThickness);
				peelShape.lineTo(-peelWidth / 2, peelThickness);
				peelShape.lineTo(-peelWidth / 2, 0);

				const extrudeSettings = {
					steps: curveSegments,
					bevelEnabled: false,
					extrudePath: curve,
				};

				const peelGeometry = new THREE.ExtrudeGeometry(peelShape, extrudeSettings);

				// Orange rind (outer surface) - vibrant orange
				const rindMaterial = new THREE.MeshStandardMaterial({
					color: 0xf57c00,
					metalness: 0.05,
					roughness: 0.55,
					side: THREE.FrontSide,
				});

				const peel = new THREE.Mesh(peelGeometry, rindMaterial);
				group.add(peel);

				// Inner pith layer (whitish-orange)
				const pithGeometry = peelGeometry.clone();
				const pithMaterial = new THREE.MeshStandardMaterial({
					color: 0xffe4b5,
					metalness: 0.0,
					roughness: 0.85,
					side: THREE.BackSide,
				});

				const pith = new THREE.Mesh(pithGeometry, pithMaterial);
				group.add(pith);

				// Add subtle texture detail with slight bumps along the peel
				const detailCount = 6;
				const detailMaterial = new THREE.MeshStandardMaterial({
					color: 0xd46a00,
					metalness: 0.0,
					roughness: 0.7,
				});

				for (let i = 0; i < detailCount; i++) {

					const t = (i + 0.5) / detailCount;
					const point = curve.getPoint(t);

					// Small bumps for orange peel texture
					const bumpGeo = new THREE.SphereGeometry(0.012, 6, 6);
					const bump = new THREE.Mesh(bumpGeo, detailMaterial);

					// Offset slightly from center
					const offsetX = (Math.random() - 0.5) * peelWidth * 0.5;
					const offsetZ = peelThickness * 0.5;

					bump.position.set(
						point.x + offsetX,
						point.y,
						point.z + offsetZ
					);

					group.add(bump);

				}

				return group;

			}

			function spawnOrangeSlice() {

				orangeSlice = createOrangeSlice();
				
				// Position inside glass at top, vertical orientation
				// Leaning slightly against the inner glass wall
				const peelX = -0.5;  // Near the inner edge of glass
				const peelZ = 0.3;
				const peelY = LIQUID_SURFACE_Y - 0.5;  // Bottom in liquid, top sticks out
				
				orangeSlice.position.set(peelX, peelY, peelZ);
				
				// Rotate to be vertical with slight lean toward glass edge
				orangeSlice.rotation.x = 0;  // Upright
				orangeSlice.rotation.y = -Math.PI * 0.3;  // Angled view
				orangeSlice.rotation.z = Math.PI * 0.75;  // Slight lean against glass
				
				orangeSlice.renderOrder = 6;
				orangeSlice.visible = orangeSliceVisible;
				scene.add(orangeSlice);

			}

			function updateOrangeSliceAnimation(time) {

				if (!orangeSlice || !orangeSliceVisible) return;

				// Very subtle movement - peel is resting against inner glass wall
				const gentleSway = Math.sin(time * 0.4) * 0.005;
				const subtleBob = Math.sin(time * 0.6) * 0.008;

				// Base position with subtle animation
				const peelX = -0.5;
				const peelZ = 0.3;
				const peelY = LIQUID_SURFACE_Y - 0.5;
				
				orangeSlice.position.x = peelX + gentleSway;
				orangeSlice.position.y = peelY + subtleBob;
				orangeSlice.position.z = peelZ + gentleSway * 0.3;

				// Very subtle rotation sway
				orangeSlice.rotation.z = Math.PI * 0.12 + Math.sin(time * 0.3) * 0.015;

			}

			function toggleOrangeSlice(visible) {

				orangeSliceVisible = visible;

				if (orangeSlice) {

					orangeSlice.visible = visible;

				}

			}

			// Hotspot creation
			function createHotspot(position, label, panelId, color = 0x7ec8e8) {

				const group = new THREE.Group();
				group.position.copy(position);

				// Inner pulsing dot - larger for easier clicking
				const dotGeometry = new THREE.SphereGeometry(0.08, 16, 16);
				const dotMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.9,
				});
				const dot = new THREE.Mesh(dotGeometry, dotMaterial);
				group.add(dot);

				// Outer ring - larger for better visibility
				const ringGeometry = new THREE.RingGeometry(0.14, 0.2, 32);
				const ringMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.6,
					side: THREE.DoubleSide,
				});
				const ring = new THREE.Mesh(ringGeometry, ringMaterial);
				ring.lookAt(camera.position);
				group.add(ring);

				// Pulse ring (animated) - larger for better visibility
				const pulseGeometry = new THREE.RingGeometry(0.12, 0.16, 32);
				const pulseMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.5,
					side: THREE.DoubleSide,
				});
				const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial);
				pulseRing.lookAt(camera.position);
				group.add(pulseRing);

				group.userData = {
					label: label,
					panelId: panelId,
					dot: dot,
					ring: ring,
					pulseRing: pulseRing,
					baseScale: 1,
					hovered: false,
				};

				scene.add(group);
				hotspots.push(group);

				return group;

			}

			function initHotspots() {

				// Push hotspots further out from glass (GLASS_RADIUS = 0.85, so we'll place them at ~1.3-1.5)
				// Whisky hotspot - at the liquid level, pushed out to the right
				createHotspot(
					new THREE.Vector3(1.4, 1.5, 0.2),
					'About Toki Whisky',
					'panelWhisky',
					0xdbb85c
				);

				// Ice hotspot - near the ice cubes, pushed out to the left-front
				createHotspot(
					new THREE.Vector3(-1.2, 2.2, 1.0),
					'The Perfect Ice',
					'panelIce',
					0xaaddff
				);

				// Glass hotspot - on the glass rim, pushed out to the right-back
				createHotspot(
					new THREE.Vector3(1.1, 2.8, -1.0),
					'Highball Glass',
					'panelGlass',
					0x7ec8e8
				);

				// Video hotspot - near the base, pushed out to the left-back
				createHotspot(
					new THREE.Vector3(-1.3, 0.6, -1.0),
					'Watch the Ritual',
					'panelVideo',
					0xff9f43
				);

			}

			function updateHotspots(time) {

				for (const hotspot of hotspots) {

					const { ring, pulseRing, hovered } = hotspot.userData;

					// Make rings face camera
					ring.lookAt(camera.position);
					pulseRing.lookAt(camera.position);

					// Pulse animation
					const pulse = 1 + Math.sin(time * 3) * 0.15;
					pulseRing.scale.set(pulse, pulse, pulse);
					pulseRing.material.opacity = 0.5 * (1 - (pulse - 1) / 0.15 * 0.5);

					// Hover effect
					const targetScale = hovered ? 1.3 : 1;
					hotspot.userData.baseScale += (targetScale - hotspot.userData.baseScale) * 0.1;
					hotspot.scale.setScalar(hotspot.userData.baseScale);

				}

			}

			function checkHotspotHover() {

				raycaster.setFromCamera(mouse, camera);

				let foundHover = false;

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						hotspot.userData.hovered = true;
						foundHover = true;

						// Show label
						const screenPos = hotspot.position.clone().project(camera);
						const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
						const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

						hotspotLabel.textContent = hotspot.userData.label;
						hotspotLabel.style.left = x + 'px';
						hotspotLabel.style.top = (y - 50) + 'px';
						hotspotLabel.classList.add('visible');

						renderer.domElement.style.cursor = 'pointer';

					} else {

						hotspot.userData.hovered = false;

					}

				}

				if (!foundHover) {

					hotspotLabel.classList.remove('visible');
					renderer.domElement.style.cursor = 'grab';

				}

			}

			function checkHotspotClick() {

				raycaster.setFromCamera(mouse, camera);

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						openPanel(hotspot.userData.panelId);
						return true;

					}

				}

				return false;

			}

			function openPanel(panelId) {

				// Close any open panel first
				closePanel();

				const panel = document.getElementById(panelId);
				if (panel) {

					activePanel = panel;
					panel.classList.add('active');
					hotspotOverlay.classList.add('active');
					hotspotLabel.classList.remove('visible');

					// Focus trap for accessibility
					const closeBtn = panel.querySelector('.hotspot-panel-close');
					if (closeBtn) closeBtn.focus();

				}

			}

			function closePanel() {

				if (activePanel) {

					activePanel.classList.remove('active');
					activePanel = null;

				}

				hotspotOverlay.classList.remove('active');

			}

			function setupPanelControls() {

				// Close buttons
				document.querySelectorAll('.hotspot-panel-close').forEach(btn => {

					btn.addEventListener('click', closePanel);
					btn.addEventListener('keydown', (e) => {

						if (e.key === 'Enter' || e.key === ' ') {

							e.preventDefault();
							closePanel();

						}

					});

				});

				// Overlay click to close
				hotspotOverlay.addEventListener('click', closePanel);

				// Escape key to close
				document.addEventListener('keydown', (e) => {

					if (e.key === 'Escape' && activePanel) {

						closePanel();

					}

				});

			}

			// Bubble system
			function initBubbleSystem() {

				bubbleGeometry = new THREE.SphereGeometry(0.012, 8, 8);
				bubbleMaterial = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					metalness: 0.0,
					roughness: 0.2,
					transparent: true,
					opacity: 0.5,
					emissive: 0xffeedd,
					emissiveIntensity: 0.1,
				});

				bubbleMesh = new THREE.InstancedMesh(bubbleGeometry, bubbleMaterial, MAX_BUBBLES);
				bubbleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
				bubbleMesh.renderOrder = 4;
				scene.add(bubbleMesh);

				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleInstances.push({
						active: false,
						position: new THREE.Vector3(),
						velocity: new THREE.Vector3(),
						size: 1,
						life: 0,
						maxLife: 0,
					});

				}

				const matrix = new THREE.Matrix4();
				matrix.makeScale(0, 0, 0);
				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleMesh.setMatrixAt(i, matrix);

				}
				bubbleMesh.instanceMatrix.needsUpdate = true;

			}

			function spawnBubble() {

				const bubble = bubbleInstances.find(b => !b.active);
				if (!bubble) return;

				const angle = Math.random() * Math.PI * 2;
				const radius = Math.random() * (LIQUID_RADIUS - 0.1);

				bubble.position.set(
					Math.cos(angle) * radius,
					LIQUID_BASE_Y + 0.05,
					Math.sin(angle) * radius
				);

				bubble.velocity.set(
					(Math.random() - 0.5) * 0.02,
					0.3 + Math.random() * 0.4,
					(Math.random() - 0.5) * 0.02
				);

				bubble.size = 0.5 + Math.random() * 1.0;
				bubble.life = 0;
				bubble.maxLife = 2 + Math.random() * 3;
				bubble.active = true;

			}

			function updateBubbles(deltaTime) {

				const spawnRate = fizzIntensity * 120;
				const spawnChance = spawnRate * deltaTime;

				if (Math.random() < spawnChance) {

					spawnBubble();

				}

				const matrix = new THREE.Matrix4();
				const position = new THREE.Vector3();
				const quaternion = new THREE.Quaternion();
				const scale = new THREE.Vector3();

				for (let i = 0; i < bubbleInstances.length; i++) {

					const bubble = bubbleInstances[i];

					if (!bubble.active) {

						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					bubble.life += deltaTime;

					if (bubble.life > bubble.maxLife || bubble.position.y > LIQUID_SURFACE_Y) {

						bubble.active = false;
						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					// Apply tilt influence
					const tiltX = liquidUniforms.uTilt.value.x;
					const tiltY = liquidUniforms.uTilt.value.y;
					bubble.velocity.x += tiltX * deltaTime * 0.5;
					bubble.velocity.z += tiltY * deltaTime * 0.5;

					// Add slight wobble
					bubble.velocity.x += (Math.random() - 0.5) * 0.05;
					bubble.velocity.z += (Math.random() - 0.5) * 0.05;

					bubble.position.x += bubble.velocity.x * deltaTime;
					bubble.position.y += bubble.velocity.y * deltaTime;
					bubble.position.z += bubble.velocity.z * deltaTime;

					const dist = Math.sqrt(
						bubble.position.x * bubble.position.x +
						bubble.position.z * bubble.position.z
					);

					if (dist > LIQUID_RADIUS - 0.05) {

						bubble.position.x *= (LIQUID_RADIUS - 0.05) / dist;
						bubble.position.z *= (LIQUID_RADIUS - 0.05) / dist;

					}

					const lifeRatio = bubble.life / bubble.maxLife;
					let sizeMultiplier = 1;

					if (lifeRatio < 0.1) {

						sizeMultiplier = lifeRatio / 0.1;

					} else if (lifeRatio > 0.9) {

						sizeMultiplier = (1 - lifeRatio) / 0.1;

					}

					const finalSize = bubble.size * sizeMultiplier;
					scale.set(finalSize, finalSize, finalSize);
					matrix.compose(bubble.position, quaternion, scale);
					bubbleMesh.setMatrixAt(i, matrix);

				}

				bubbleMesh.instanceMatrix.needsUpdate = true;

			}

			function init() {

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputColorSpace = THREE.SRGBColorSpace;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.1;
				document.body.appendChild(renderer.domElement);

				scene = new THREE.Scene();
				// Fallback color if image fails to load
				scene.background = new THREE.Color(0x87CEEB);

				// Load background image texture
				const textureLoader = new THREE.TextureLoader();
				textureLoader.load(
					'images/wallpaper-2.jpeg',
					(texture) => {
						backgroundTexture = texture;
						backgroundTexture.colorSpace = THREE.SRGBColorSpace;
						backgroundTexture.flipY = true;
						updateBackgroundCover();
						scene.background = backgroundTexture;
						console.log('Background image loaded successfully', {
							width: texture.image.width,
							height: texture.image.height,
							aspect: texture.image.width / texture.image.height
						});
					},
					(progress) => {
						// Progress callback (optional)
					},
					(error) => {
						console.error('Failed to load background image:', error);
						console.error('Attempted path: images/wallpaper.jpg');
						// Keep fallback color
					}
				);

				// Create simple environment for reflections on ice
				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				const envScene = new THREE.Scene();
				envScene.background = new THREE.Color(0xaaddff);
				
				// Add gradient sphere for soft environment lighting
				const envGeo = new THREE.SphereGeometry(50, 32, 32);
				const envMat = new THREE.MeshBasicMaterial({
					color: 0xeef6ff,
					side: THREE.BackSide,
				});
				const envMesh = new THREE.Mesh(envGeo, envMat);
				envScene.add(envMesh);
				
				const envMap = pmremGenerator.fromScene(envScene).texture;
				scene.environment = envMap;
				pmremGenerator.dispose();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
				// Start zoomed out to max distance
				camera.position.set(0, 3.5, 8);
				camera.lookAt(0, 1.2, 0);

				// Bright ambient lighting for light scene
				const ambient = new THREE.AmbientLight(0xffffff, 1.0);
				scene.add(ambient);

				const hemi = new THREE.HemisphereLight(0x87CEEB, 0xffffff, 0.8);
				scene.add(hemi);

				// Key light (bright white/warm)
				const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
				keyLight.position.set(3, 5, 2);
				scene.add(keyLight);

				// Fill light (soft blue from sky)
				const fillLight = new THREE.DirectionalLight(0xaaddff, 1.2);
				fillLight.position.set(-3, 3, -2);
				scene.add(fillLight);

				// Rim light (warm accent)
				const rimLight = new THREE.DirectionalLight(0xffeedd, 1.0);
				rimLight.position.set(0, 2, -4);
				scene.add(rimLight);

				// Bar surface - rich wood brown
				const barGeometry = new THREE.CylinderGeometry(8, 8, 0.3, 64);
				const barMaterial = new THREE.MeshStandardMaterial({
					color: 0x5c3d2e,
					roughness: 0.6,
					metalness: 0.1,
				});
				const bar = new THREE.Mesh(barGeometry, barMaterial);
				bar.position.y = -0.15;
				scene.add(bar);

				buildLiquid();
				buildGlass();
				initBubbleSystem();

				// Spawn initial ice
				for (let i = 0; i < iceConfig.quantity; i++) {

					spawnIce();

				}

				// Spawn orange slice
				spawnOrangeSlice();

				// Initialize hotspots
				initHotspots();

				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
				controls.target.set(0, 1.2, 0);
				controls.minDistance = 2.5;
				controls.maxDistance = 8;
				// Prevent orbiting below the glass/table by clamping polar angle just above the horizon
				controls.maxPolarAngle = Math.PI * 0.49;

				raycaster = new THREE.Raycaster();
				renderer.domElement.addEventListener('pointermove', onPointerMove);
				renderer.domElement.addEventListener('pointerdown', onPointerDown);

				window.addEventListener('resize', onWindowResize);

				setupControls();
				setupPanelControls();
				setupMotionOverlay();

				// Attempt to start background audio (may be blocked by browser autoplay policy)
				const audioElement = document.getElementById('backgroundAudio');
				const playPromise = audioElement.play();
				if (playPromise !== undefined) {
					playPromise.then(() => {
						// Autoplay succeeded - update button state
						const audioToggle = document.getElementById('audioToggle');
						const playIcon = document.getElementById('playIcon');
						const pauseIcon = document.getElementById('pauseIcon');
						audioToggle.classList.add('active');
						playIcon.style.display = 'none';
						pauseIcon.style.display = 'block';
					}).catch((error) => {
						// Autoplay was prevented - user will need to click play button
						console.log('Autoplay prevented. User can click play button to start audio.');
					});
				}

				renderer.setAnimationLoop(animate);

			}

			function buildGlass() {

				// Outer glass cylinder
				const outerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS,
					GLASS_RADIUS * 0.92,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialOuter = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 0.97,
					opacity: 1,
					transparent: true,
					thickness: 0.08,
					clearcoat: 1.0,
					ior: 1.52,
					envMapIntensity: 1.2,
					depthWrite: false,
				});

				glassOuter = new THREE.Mesh(outerGeometry, glassMaterialOuter);
				glassOuter.position.y = GLASS_HEIGHT / 2 + 0.1;
				glassOuter.renderOrder = 10;
				scene.add(glassOuter);

				// Inner glass surface
				const innerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS - GLASS_THICKNESS,
					(GLASS_RADIUS * 0.92) - GLASS_THICKNESS,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialInner = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 0.97,
					opacity: 1,
					transparent: true,
					thickness: 0.08,
					clearcoat: 1.0,
					ior: 1.52,
					side: THREE.BackSide,
					depthWrite: false,
				});

				glassInner = new THREE.Mesh(innerGeometry, glassMaterialInner);
				glassInner.position.y = GLASS_HEIGHT / 2 + 0.1;
				glassInner.renderOrder = 9;
				scene.add(glassInner);

				// Glass bottom
				const bottomGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS * 0.92,
					GLASS_RADIUS * 0.92,
					0.12,
					64
				);
				const bottomMaterial = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.05,
					transmission: 0.9,
					transparent: true,
					thickness: 0.12,
					ior: 1.52,
					depthWrite: false,
				});

				const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
				bottom.position.y = 0.06;
				bottom.renderOrder = 8;
				scene.add(bottom);

			}

			function buildLiquid() {

				liquidUniforms = {
					uTime: { value: 0 },
					uTilt: { value: new THREE.Vector2() },
					uRippleCenter: { value: new THREE.Vector2(10000, 10000) },
					uRippleStrength: { value: 0 },
					uFizz: { value: fizzIntensity },
				};

				const surfaceSegments = 64;
				const surfaceGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, surfaceSegments);
				surfaceGeometry.rotateX(-Math.PI * 0.5);
				surfaceGeometry.translate(0, LIQUID_SURFACE_Y, 0);

				const surfaceMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_COLOR,
					metalness: 0.15,
					roughness: 0.08,
					transparent: true,
					opacity: 0.88,
					emissive: LIQUID_DEEP_COLOR,
					emissiveIntensity: 0.08,
					side: THREE.DoubleSide,
					depthWrite: true,
				});

				surfaceMaterial.onBeforeCompile = (shader) => {

					shader.uniforms.uTime = liquidUniforms.uTime;
					shader.uniforms.uTilt = liquidUniforms.uTilt;
					shader.uniforms.uRippleCenter = liquidUniforms.uRippleCenter;
					shader.uniforms.uRippleStrength = liquidUniforms.uRippleStrength;
					shader.uniforms.uFizz = liquidUniforms.uFizz;

					shader.vertexShader = shader.vertexShader.replace(
						'#include <common>',
						`#include <common>
						uniform float uTime;
						uniform vec2 uTilt;
						uniform vec2 uRippleCenter;
						uniform float uRippleStrength;
						uniform float uFizz;
						varying float vWaveHeight;`
					);

					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						`vec3 transformed = vec3(position);
						
						// Tilt effect
						float tilt = dot(transformed.xz, uTilt) * 0.2;
						
						// Gentle waves
						float wave = sin(transformed.x * 4.0 + uTime * 1.5) * 0.012
						           + sin(transformed.z * 4.5 + uTime * 1.1) * 0.012
						           + sin((transformed.x + transformed.z) * 3.0 + uTime * 1.8) * 0.008;
						
						// Fizz surface disturbance
						float fizz = sin(transformed.x * 20.0 + uTime * 5.0) * 0.003 * uFizz
						           + sin(transformed.z * 22.0 + uTime * 6.0) * 0.003 * uFizz;
						
						// Ripple from touch
						float dist = length(transformed.xz - uRippleCenter);
						float ripple = uRippleStrength * exp(-dist * 3.0) * sin(12.0 * dist - uTime * 5.0);
						
						float totalWave = tilt + wave + fizz + ripple;
						transformed.y += totalWave;
						vWaveHeight = totalWave;`
					);

					shader.fragmentShader = shader.fragmentShader.replace(
						'#include <common>',
						`#include <common>
						varying float vWaveHeight;`
					);

					surfaceMaterial.userData.shader = shader;

				};

				liquidSurface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
				liquidSurface.renderOrder = 2;
				scene.add(liquidSurface);

				// Liquid body (cylinder)
				const bodyGeometry = new THREE.CylinderGeometry(
					LIQUID_RADIUS,
					LIQUID_RADIUS,
					LIQUID_HEIGHT,
					64,
					1,
					true
				);
				bodyGeometry.translate(0, LIQUID_BASE_Y + LIQUID_HEIGHT * 0.5, 0);

				const bodyMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_COLOR,
					metalness: 0.1,
					roughness: 0.12,
					transparent: true,
					opacity: 0.75,
					emissive: LIQUID_DEEP_COLOR,
					emissiveIntensity: 0.05,
					side: THREE.DoubleSide,
					depthWrite: false,
				});

				liquidBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
				liquidBody.renderOrder = 1;
				scene.add(liquidBody);

				// Liquid bottom
				const bottomGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, 64);
				bottomGeometry.rotateX(Math.PI * 0.5);
				bottomGeometry.translate(0, LIQUID_BASE_Y, 0);

				const bottomMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_DEEP_COLOR,
					metalness: 0.1,
					roughness: 0.2,
					transparent: true,
					opacity: 0.7,
					emissive: 0x8b6914,
					emissiveIntensity: 0.03,
					side: THREE.DoubleSide,
					depthWrite: false,
				});

				const liquidBottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
				liquidBottom.renderOrder = 0;
				scene.add(liquidBottom);

				// Invisible raycast plane
				waterPlane = new THREE.Mesh(
					new THREE.PlaneGeometry(LIQUID_RADIUS * 2, LIQUID_RADIUS * 2),
					new THREE.MeshBasicMaterial({ visible: false })
				);
				waterPlane.rotation.x = -Math.PI * 0.5;
				waterPlane.position.y = LIQUID_SURFACE_Y;
				scene.add(waterPlane);

			}

			function setupControls() {

				const fizzSlider = document.getElementById('fizzSlider');
				const fizzValue = document.getElementById('fizzValue');

				const handleFizzChange = () => {

					fizzIntensity = parseFloat(fizzSlider.value) / 100;
					fizzValue.textContent = fizzSlider.value + '%';
					liquidUniforms.uFizz.value = fizzIntensity;

				};

				fizzSlider.addEventListener('input', handleFizzChange);

				// Audio controls
				const audioElement = document.getElementById('backgroundAudio');
				const audioToggle = document.getElementById('audioToggle');
				const playIcon = document.getElementById('playIcon');
				const pauseIcon = document.getElementById('pauseIcon');
				const volumeSlider = document.getElementById('volumeSlider');
				const volumeValue = document.getElementById('volumeValue');

				let isPlaying = false;

				// Set initial volume
				audioElement.volume = volumeSlider.value / 100;

				const handleToggleAudio = () => {

					if (isPlaying) {

						audioElement.pause();
						isPlaying = false;
						audioToggle.classList.remove('active');
						playIcon.style.display = 'block';
						pauseIcon.style.display = 'none';

					} else {

						audioElement.play().catch((error) => {

							console.error('Error playing audio:', error);

						});
						isPlaying = true;
						audioToggle.classList.add('active');
						playIcon.style.display = 'none';
						pauseIcon.style.display = 'block';

					}

				};

				const handleVolumeChange = () => {

					const volume = parseFloat(volumeSlider.value) / 100;
					audioElement.volume = volume;
					volumeValue.textContent = volumeSlider.value + '%';

				};

				audioToggle.addEventListener('click', handleToggleAudio);
				audioToggle.addEventListener('keydown', (e) => {

					if (e.key === 'Enter' || e.key === ' ') {

						e.preventDefault();
						handleToggleAudio();

					}

				});

				volumeSlider.addEventListener('input', handleVolumeChange);

				// Handle audio ended (for looping)
				audioElement.addEventListener('ended', () => {

					if (isPlaying) {

						audioElement.play();

					}

				});

				// Handle audio play/pause events
				audioElement.addEventListener('play', () => {

					isPlaying = true;
					audioToggle.classList.add('active');
					playIcon.style.display = 'none';
					pauseIcon.style.display = 'block';

				});

				audioElement.addEventListener('pause', () => {

					isPlaying = false;
					audioToggle.classList.remove('active');
					playIcon.style.display = 'block';
					pauseIcon.style.display = 'none';

				});

			}

			function onPointerMove(event) {

				setMouseFromEvent(event);
				checkHotspotHover();

			}

			function onPointerDown(event) {

				setMouseFromEvent(event);

				// Check hotspot click first
				if (checkHotspotClick()) return;

				triggerRipple();

			}

			function setMouseFromEvent(event) {

				const rect = renderer.domElement.getBoundingClientRect();
				mouse.set(
					((event.clientX - rect.left) / rect.width) * 2 - 1,
					-((event.clientY - rect.top) / rect.height) * 2 + 1
				);

			}

			function triggerRipple() {

				raycaster.setFromCamera(mouse, camera);
				const hit = raycaster.intersectObject(waterPlane);
				if (hit.length === 0) return;

				const point = hit[0].point;
				liquidUniforms.uRippleCenter.value.set(point.x, point.z);
				liquidUniforms.uRippleStrength.value = Math.min(
					liquidUniforms.uRippleStrength.value + 0.4,
					1.2
				);

			}

			function setupMotionOverlay() {

				motionOverlay = document.getElementById('overlay');
				enableMotionButton = document.getElementById('enableMotionButton');

				if (!enableMotionButton) return;

				enableMotionButton.addEventListener('click', () => {

					if (motionOverlay) motionOverlay.style.display = 'none';
					requestMotionAccess();

				}, { once: true });

			}

			async function requestMotionAccess() {

				const granted = await askForMotionPermission();
				if (!granted) return;

				motionState.enabled = true;
				startMotionListeners();

			}

			async function askForMotionPermission() {

				const tryPermission = async (ctor) => {

					if (typeof ctor === 'undefined' || typeof ctor.requestPermission !== 'function') return true;
					try {

						const response = await ctor.requestPermission();
						return response === 'granted';

					} catch (err) {

						console.warn('Motion permission request failed', err);
						return false;

					}

				};

				const motionGranted = await tryPermission(window.DeviceMotionEvent);
				const orientationGranted = await tryPermission(window.DeviceOrientationEvent);
				return motionGranted || orientationGranted;

			}

			function startMotionListeners() {

				if (motionState.available) return;

				window.addEventListener('deviceorientation', handleOrientation, true);
				window.addEventListener('devicemotion', handleMotion, true);
				motionState.available = true;

			}

			function handleOrientation(event) {

				if (!motionState.enabled) return;

				const gamma = event.gamma ?? 0;
				const beta = event.beta ?? 0;

				const normX = THREE.MathUtils.clamp(gamma / 40, -1, 1);
				const normY = THREE.MathUtils.clamp(beta / 40, -1, 1);

				motionState.targetTilt.set(normX, normY);
				motionState.lastUpdate = performance.now();

			}

			function handleMotion(event) {

				if (!motionState.enabled) return;
				if (!event.accelerationIncludingGravity) return;

				const { x = 0, y = 0, z = 0 } = event.accelerationIncludingGravity;
				const magnitude = Math.sqrt(x * x + y * y + z * z);
				const impulse = THREE.MathUtils.clamp(Math.abs(magnitude - 9.8) / 10, 0, 1);
				motionState.rippleStrength = Math.max(motionState.rippleStrength, impulse * 0.4);
				motionState.lastUpdate = performance.now();

			}

			function applyMotion() {

				const now = performance.now();
				const fresh = now - motionState.lastUpdate < 600;

				if (motionState.enabled && fresh) {

					motionState.tilt.lerp(motionState.targetTilt, 0.1);
					liquidUniforms.uTilt.value.lerp(motionState.tilt, 0.15);

					if (motionState.rippleStrength > 0.02) {

						liquidUniforms.uRippleStrength.value = Math.min(
							liquidUniforms.uRippleStrength.value + motionState.rippleStrength,
							1.1
						);
						motionState.rippleStrength *= 0.88;

					} else {

						motionState.rippleStrength *= 0.75;

					}

				} else {

					motionState.tilt.lerp(new THREE.Vector2(), 0.04);
					liquidUniforms.uTilt.value.lerp(motionState.tilt, 0.15);

				}

				liquidUniforms.uRippleStrength.value *= 0.95;

			}

			function animate() {

				const deltaTime = 1 / 60;
				elapsedTime += deltaTime;

				liquidUniforms.uTime.value += 0.016;
				applyMotion();

				// Update animations
				updateBubbles(deltaTime);
				updateIceAnimation(elapsedTime);
				updateOrangeSliceAnimation(elapsedTime);
				updateHotspots(elapsedTime);

				controls.update();
				renderer.render(scene, camera);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
				updateBackgroundCover();

			}

		</script>
	</body>
</html>
