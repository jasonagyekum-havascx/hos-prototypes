<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - Toki Japanese Highball</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500&family=Cormorant+Garamond:wght@400;500&display=swap');

			body {
				font-family: 'Noto Sans JP', sans-serif;
				background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #E0F4FF 100%);
			}

      #info {
        display: none; /* Hidden per user request */
      }

			#info .title-wrapper span {
				color: #7ec8e8;
				font-family: 'Cormorant Garamond', serif;
				font-weight: 500;
				letter-spacing: 1px;
			}

			#info .title-wrapper a {
				color: #ffffff;
			}

			#info small {
				color: rgba(255, 255, 255, 0.7);
			}

			#drinkControls {
				position: fixed;
				bottom: 20px;
				left: 20px;
				background: rgba(20, 40, 60, 0.92);
				border: 1px solid rgba(100, 160, 200, 0.3);
				border-radius: 16px;
				padding: 20px 24px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 13px;
				backdrop-filter: blur(12px);
				z-index: 100;
				min-width: 220px;
			}

			#drinkControls h3 {
				margin: 0 0 16px 0;
				font-size: 15px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
				font-family: 'Cormorant Garamond', serif;
				text-transform: uppercase;
			}

			.control-row {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 14px;
			}

			.control-row:last-child {
				margin-bottom: 0;
			}

			.control-row label {
				color: rgba(255, 255, 255, 0.8);
				font-size: 12px;
				min-width: 70px;
			}

			.control-row .controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			#drinkControls button {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.4);
				color: #7ec8e8;
				padding: 6px 12px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 12px;
				font-weight: 500;
				transition: all 0.2s ease;
				font-family: inherit;
			}

			#drinkControls button:hover {
				background: rgba(126, 200, 232, 0.25);
				border-color: rgba(126, 200, 232, 0.6);
			}

			#drinkControls button:active {
				transform: scale(0.96);
			}

			#drinkControls button.active {
				background: rgba(126, 200, 232, 0.35);
				border-color: #7ec8e8;
			}

			#fizzValue {
				min-width: 32px;
				text-align: center;
				font-weight: 500;
				color: #ffffff;
			}

			.slider-control {
				width: 70px;
				height: 4px;
				-webkit-appearance: none;
				appearance: none;
				background: rgba(126, 200, 232, 0.25);
				border-radius: 2px;
				outline: none;
				cursor: pointer;
			}

			.slider-control::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border-radius: 50%;
				cursor: pointer;
				transition: transform 0.15s ease;
			}

			.slider-control::-webkit-slider-thumb:hover {
				transform: scale(1.15);
			}

			.slider-control::-moz-range-thumb {
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border: none;
				border-radius: 50%;
				cursor: pointer;
			}

			#brandLabel {
				position: fixed;
				bottom: 20px;
				right: 20px;
				font-family: 'Cormorant Garamond', serif;
				font-size: 24px;
				color: rgba(20, 60, 90, 0.5);
				letter-spacing: 3px;
				text-transform: uppercase;
				writing-mode: vertical-rl;
				text-orientation: mixed;
				z-index: 100;
			}

			/* Hotspot Info Panel Styles */
			.hotspot-panel {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%) scale(0.9);
				background: rgba(20, 40, 60, 0.96);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 20px;
				padding: 32px 40px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				backdrop-filter: blur(16px);
				z-index: 200;
				max-width: 420px;
				width: 90%;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
				box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
			}

			.hotspot-panel.active {
				opacity: 1;
				visibility: visible;
				transform: translate(-50%, -50%) scale(1);
			}

			.hotspot-panel-header {
				display: flex;
				justify-content: space-between;
				align-items: flex-start;
				margin-bottom: 20px;
			}

			.hotspot-panel h2 {
				margin: 0;
				font-family: 'Cormorant Garamond', serif;
				font-size: 26px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
			}

			.hotspot-panel-close {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.3);
				color: #7ec8e8;
				width: 36px;
				height: 36px;
				border-radius: 50%;
				cursor: pointer;
				font-size: 20px;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.2s ease;
				flex-shrink: 0;
				margin-left: 16px;
			}

			.hotspot-panel-close:hover {
				background: rgba(126, 200, 232, 0.3);
				transform: scale(1.1);
			}

			.hotspot-panel p {
				margin: 0 0 16px 0;
				font-size: 14px;
				line-height: 1.7;
				color: rgba(255, 255, 255, 0.85);
			}

			.hotspot-panel p:last-child {
				margin-bottom: 0;
			}

			.hotspot-panel .highlight {
				color: #dbb85c;
				font-weight: 500;
			}

			.hotspot-panel video {
				width: 100%;
				border-radius: 12px;
				margin-top: 16px;
				background: #000;
			}

			.hotspot-panel .video-placeholder {
				width: 100%;
				aspect-ratio: 16/9;
				background: linear-gradient(135deg, rgba(126, 200, 232, 0.15), rgba(219, 184, 92, 0.15));
				border-radius: 12px;
				margin-top: 16px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				border: 1px dashed rgba(126, 200, 232, 0.3);
			}

			.hotspot-panel .video-placeholder svg {
				width: 48px;
				height: 48px;
				fill: rgba(126, 200, 232, 0.6);
				margin-bottom: 12px;
			}

			.hotspot-panel .video-placeholder span {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.5);
			}

			.hotspot-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.5);
				z-index: 150;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s ease;
			}

			.hotspot-overlay.active {
				opacity: 1;
				visibility: visible;
			}

			/* Hotspot Label Tooltips */
			.hotspot-label {
				position: fixed;
				background: rgba(20, 40, 60, 0.9);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 8px;
				padding: 8px 14px;
				color: #7ec8e8;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 12px;
				font-weight: 500;
				pointer-events: none;
				z-index: 120;
				opacity: 0;
				transform: translateY(8px);
				transition: all 0.25s ease;
				white-space: nowrap;
				backdrop-filter: blur(8px);
			}

		.hotspot-label.visible {
			opacity: 1;
			transform: translateY(0);
		}

		/* lil-gui styling */
		.lil-gui {
			--width: 320px;
			--background-color: rgba(20, 40, 60, 0.92);
			--widget-color: rgba(126, 200, 232, 0.3);
			--hover-color: rgba(126, 200, 232, 0.5);
			--focus-color: rgba(126, 200, 232, 0.6);
			--number-color: #7ec8e8;
			--string-color: #7ec8e8;
			--font-size: 12px;
			--input-font-size: 12px;
			--font-family: 'Noto Sans JP', sans-serif;
			--padding: 8px;
			--spacing: 6px;
			--title-height: 32px;
			--title-background-color: rgba(126, 200, 232, 0.15);
			--title-text-color: #7ec8e8;
			--widget-height: 24px;
			--border-color: rgba(126, 200, 232, 0.3);
			--border-radius: 8px;
			z-index: 1000;
			backdrop-filter: blur(12px);
		}

		.lil-gui.root {
			position: fixed;
			top: 20px;
			right: 20px;
			max-height: calc(100vh - 40px);
			overflow-y: auto;
			overflow-x: hidden;
		}

		/* Ensure GUI content doesn't overflow */
		.lil-gui .children {
			max-height: calc(100vh - 100px);
			overflow-y: auto;
		}

	/* Keyboard shortcuts hint - HIDDEN */
	#keyboardHints {
		display: none !important;
	}

	</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Toki Japanese Highball</span>
			</div>

			<small>
				Tap hotspots to learn more. Drag to orbit.
			</small>
		</div>

		<div id="drinkControls" role="region" aria-label="Drink controls">
			<h3>Highball Settings</h3>
			<div class="control-row">
				<label for="fizzSlider">Carbonation</label>
				<div class="controls">
					<input type="range" id="fizzSlider" class="slider-control" min="0" max="300" step="10" value="300" aria-label="Fizz intensity">
					<span id="fizzValue">300%</span>
				</div>
			</div>
			<div class="control-row">
				<label id="sliceLabel">Orange Peel</label>
				<div class="controls">
					<button id="sliceToggle" aria-pressed="false" aria-describedby="sliceLabel">Hidden</button>
				</div>
			</div>
		</div>

	<div id="brandLabel">TOKI</div>

	<!-- Keyboard Shortcuts Hint -->
	<div id="keyboardHints">
		<h4>⌨️ Keyboard Shortcuts</h4>
		<div><kbd>G</kbd> Toggle Glass</div>
		<div><kbd>H</kbd> Toggle Light Helpers</div>
		<div><kbd>T</kbd> Translate Gizmo</div>
		<div><kbd>R</kbd> Rotate Gizmo</div>
		<div><kbd>S</kbd> Scale Gizmo</div>
		<div><kbd>D</kbd> Detach Gizmo</div>
	</div>

	<!-- Hotspot Overlay -->
		<div id="hotspotOverlay" class="hotspot-overlay" role="presentation"></div>

		<!-- Hotspot Info Panels -->
		<div id="panelWhisky" class="hotspot-panel" role="dialog" aria-labelledby="panelWhiskyTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelWhiskyTitle">Suntory Toki</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				<span class="highlight">Toki</span> means "time" in Japanese, representing the harmony of old and new. 
				This blended Japanese whisky combines malt from Hakushu and Yamazaki distilleries with 
				grain whisky from Chita.
			</p>
			<p>
				Silky with a subtle sweetness, it's the perfect base for a refreshing Highball—Japan's 
				most popular way to enjoy whisky.
			</p>
		</div>

		<div id="panelIce" class="hotspot-panel" role="dialog" aria-labelledby="panelIceTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelIceTitle">The Perfect Ice</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				In Japan, ice is an art form. Large, <span class="highlight">crystal-clear cubes</span> are essential 
				for the perfect Highball—they melt slowly, keeping your drink cold without over-diluting.
			</p>
			<p>
				The best Highball bars in Tokyo hand-carve their ice from massive blocks, ensuring purity 
				and the ideal melting rate.
			</p>
		</div>

		<div id="panelGlass" class="hotspot-panel" role="dialog" aria-labelledby="panelGlassTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelGlassTitle">Highball Glass</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				The tall, slender <span class="highlight">Collins glass</span> is traditional for Japanese Highballs. 
				Its narrow profile preserves carbonation and creates an elegant presentation.
			</p>
			<p>
				Many Japanese bars freeze their glasses beforehand, creating a frosty exterior that 
				keeps your Highball perfectly chilled from the first sip to the last.
			</p>
		</div>

		<div id="panelVideo" class="hotspot-panel" role="dialog" aria-labelledby="panelVideoTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelVideoTitle">The Ritual</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				Watch how Japanese bartenders craft the <span class="highlight">perfect Toki Highball</span>—a ritual 
				of precision and care.
			</p>
			<div class="video-placeholder">
				<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
					<path d="M8 5v14l11-7z"/>
				</svg>
				<span>Video content placeholder</span>
			</div>
		</div>

		<!-- Hotspot Label Tooltip -->
		<div id="hotspotLabel" class="hotspot-label"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { TransformControls } from 'three/addons/controls/TransformControls.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
		import { setupLights, updateLightHelpers, toggleHelpers, createLightGUI } from './lights-config.js';
		import { liquidConfig, applyLiquidConfig } from './liquid-config.js';

		let renderer, scene, camera, controls;
		let liquidSurface, liquidBody;
		let liquidUniforms;
		let lights; // Store lights reference for helpers
		let gui; // GUI panel
		let transformControls; // Gizmos for dragging lights
		let floor = null; // Floor mesh reference
		let glassModelMaterial = null; // Glass model material reference
		let iceCubeMaterial = null; // Ice cube material reference (for GUI controls)
			let raycaster;
			let waterPlane;
			let glassOuter, glassInner, glassBottom;
			const mouse = new THREE.Vector2();

			// Hotspot system
			const hotspots = [];
			let activePanel = null;
			const hotspotLabel = document.getElementById('hotspotLabel');
			const hotspotOverlay = document.getElementById('hotspotOverlay');

			// Bubble system
			let bubbleGeometry, bubbleMaterial;
			let bubbleInstances = [];
			const MAX_BUBBLES = 500;
			let bubbleMesh;

		// Orange slice
		let orangeSlice;
		let orangeSliceVisible = false;

		// Cube model
		let cubeModel;
		
		// Floor model
		let floorModel;

		// Ice cube GLB model (for first ice cube)
		let iceCubeGLBModel = null;

			// Ice cubes (simple floating objects)
			const iceObjects = [];
			const iceConfig = {
				quantity: 2,
				maxQuantity: 4,
				baseSize: 0.12,
				sizeMultiplier: 3.75,
			};

			// Fizz configuration
			let fizzIntensity = 3.0;

			// Time tracking
			let elapsedTime = 0;

			// Highball glass dimensions (taller and slender)
			const GLASS_RADIUS = 0.85;
			const GLASS_HEIGHT = 2.8;
			const GLASS_THICKNESS = 0.04;

			// Liquid configuration
			const LIQUID_RADIUS = GLASS_RADIUS - GLASS_THICKNESS - 0.02;
			const LIQUID_HEIGHT = 2.2;
			const LIQUID_BASE_Y = 0.1;
			const LIQUID_SURFACE_Y = LIQUID_BASE_Y + LIQUID_HEIGHT;

			// Toki Highball golden amber color (20% darker)
			const LIQUID_COLOR = 0xaf934a;
			const LIQUID_DEEP_COLOR = 0xa18033;

			init();

			function createIceMaterial() {

				// Use MeshPhysicalMaterial for realistic ice with transmission/refraction like glass
				const material = new THREE.MeshPhysicalMaterial({
					color: 0xd8e4f0,
					metalness: 0.0,
					roughness: 0.1,
					transmission: 0.7,      // Moderate transmission - visible but transparent
					opacity: 0.85,         // Slightly transparent for visibility
					transparent: true,
					thickness: 0.3,         // Ice thickness for refraction calculation
					ior: 1.31,              // Index of refraction for ice (slightly less than glass)
					clearcoat: 0.8,         // Glossy clear coat layer
					clearcoatRoughness: 0.2,
					envMapIntensity: 1.2,
					side: THREE.FrontSide,
					depthWrite: true,       // Enable depth write for better visibility
					emissive: 0x000000,
					emissiveIntensity: 0,
				});
				
				// Store reference for GUI controls
				if (!iceCubeMaterial) {
					iceCubeMaterial = material;
				}
				
				return material;

			}

			function createIceMesh(size) {

				// Rectangular ice cube typical for highballs
				const geometry = new THREE.BoxGeometry(size * 1.8, size * 2.2, size * 1.8);
				const material = createIceMaterial();
				const mesh = new THREE.Mesh(geometry, material);
				mesh.renderOrder = 3;
				mesh.userData.baseSize = size;
				mesh.userData.isProcedural = true;

				// Add inner frosted core for realism
				const innerGeometry = new THREE.BoxGeometry(size * 1.4, size * 1.8, size * 1.4);
				const innerMaterial = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0.0,
					roughness: 0.9,
					transmission: 0.4,
					opacity: 0.5,
					transparent: true,
					thickness: 0.2,
					ior: 1.31,
					side: THREE.FrontSide,
					depthWrite: true,
				});
				const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
				innerMesh.renderOrder = 2;
				mesh.add(innerMesh);

				return mesh;

			}

			function getCurrentIceSize() {

				return iceConfig.baseSize * iceConfig.sizeMultiplier;

			}

			// Load ice-cube.glb model
			function loadIceCubeGLB() {
				const dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

				const gltfLoader = new GLTFLoader();
				gltfLoader.setDRACOLoader(dracoLoader);

				gltfLoader.load(
					'models/glb/ice-cube.glb',
					(gltf) => {
						iceCubeGLBModel = gltf.scene;
						// Store the original model for cloning
						console.log('Ice cube GLB model loaded successfully');
						
						// Extract material reference from GLB model
						iceCubeGLBModel.traverse((child) => {
							if (child.isMesh && child.material && !iceCubeMaterial) {
								iceCubeMaterial = child.material;
							}
						});
						
						// If ice cubes haven't been spawned yet, they'll use GLB when spawned
						// Otherwise, replace all procedural ice cubes with GLB models
						if (iceObjects.length > 0) {
							// Replace all procedural ice cubes with GLB models
							const size = getCurrentIceSize();
							
							iceObjects.forEach((ice, index) => {
								if (ice.mesh.userData.isProcedural) {
									const oldPosition = ice.mesh.position.clone();
									const oldRotation = ice.mesh.rotation.clone();
									
									scene.remove(ice.mesh);
									ice.mesh.geometry.dispose();
									ice.mesh.material.dispose();
									
									// Create new GLB ice cube with same size
									const mesh = iceCubeGLBModel.clone();
									
									// Calculate scale to match procedural ice cube size
									const box = new THREE.Box3().setFromObject(mesh);
									const glbSize = box.getSize(new THREE.Vector3());
									const targetWidth = size * 1.8;
									const targetHeight = size * 2.2;
									const scaleX = targetWidth / Math.max(glbSize.x, 0.001);
									const scaleY = targetHeight / Math.max(glbSize.y, 0.001);
									const scaleZ = targetWidth / Math.max(glbSize.z, 0.001);
									const avgScale = (scaleX + scaleY + scaleZ) / 3;
									mesh.scale.set(avgScale, avgScale, avgScale);
									
									mesh.traverse((child) => {
										if (child.isMesh) {
											child.castShadow = true;
											child.receiveShadow = true;
											child.renderOrder = 3;
											
											// Apply ice material with transmission properties
											if (child.material) {
												// Convert to MeshPhysicalMaterial if not already
												if (!(child.material instanceof THREE.MeshPhysicalMaterial)) {
													const iceMat = new THREE.MeshPhysicalMaterial({
														color: child.material.color || 0xd8e4f0,
														metalness: child.material.metalness !== undefined ? child.material.metalness : 0.0,
														roughness: child.material.roughness !== undefined ? child.material.roughness : 0.1,
														transmission: 0.7,
														opacity: 0.85,
														transparent: true,
														thickness: 0.3,
														ior: 1.31,
														clearcoat: 0.8,
														clearcoatRoughness: 0.2,
														envMapIntensity: child.material.envMapIntensity || 1.2,
														side: child.material.side || THREE.FrontSide,
														depthWrite: true,
													});
													child.material = iceMat;
												} else {
													// Update existing MeshPhysicalMaterial with ice defaults
													if (child.material.transmission === undefined) child.material.transmission = 0.7;
													if (child.material.ior === undefined) child.material.ior = 1.31;
													if (child.material.thickness === undefined) child.material.thickness = 0.3;
													if (child.material.clearcoat === undefined) child.material.clearcoat = 0.8;
													if (child.material.clearcoatRoughness === undefined) child.material.clearcoatRoughness = 0.2;
													if (child.material.opacity === undefined || child.material.opacity === 1) child.material.opacity = 0.85;
													child.material.depthWrite = true;
												}
												
												// Store material reference for GUI controls (use first mesh material)
												if (!iceCubeMaterial) {
													iceCubeMaterial = child.material;
												}
											}
										}
									});
									
									mesh.renderOrder = 3;
									mesh.userData.baseSize = size;
									mesh.userData.isProcedural = false;
									
									// Preserve position and rotation from old ice cube
									mesh.position.copy(oldPosition);
									mesh.rotation.copy(oldRotation);
									
									scene.add(mesh);
									ice.mesh = mesh;
									console.log(`Replaced procedural ice cube ${index} with GLB model`);
								}
							});
							
							// Create ice cube GUI if not already created
							if (gui && iceObjects.length > 0) {
								// Check if GUI already has ice cube folder
								const existingFolder = gui.children.find(child => child._title === 'Ice Cube Material');
								if (!existingFolder) {
									createIceCubeGUI(gui);
								}
							}
						}
					},
					(progress) => {
						console.log('Loading ice cube:', (progress.loaded / progress.total * 100) + '%');
					},
					(error) => {
						console.error('Error loading ice cube model:', error);
					}
				);
			}

			function updateAllIceSizes() {

				const newSize = getCurrentIceSize();

				for (const ice of iceObjects) {

					const scale = newSize / ice.mesh.userData.baseSize;
					ice.mesh.scale.set(scale, scale, scale);

				}

			}

			function getIceHeight(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Ice height is 2.2 * size * scale
				return size * 2.2 * scale * 0.5;

			}

			function findNonOverlappingPosition(size, iceIndex) {

				const iceHeight = size * 2.2;
				
				// For 2 stacked ice cubes - deterministic positioning
				if (iceIndex === 0) {

					// First (top) ice cube - breaks the surface
					// Positioned at center, 30% submerged
					return { 
						x: 0, 
						z: 0, 
						y: LIQUID_SURFACE_Y - iceHeight * 0.35
					};

				} else {

					// Second (bottom) ice cube - stacked below the first
					// Positioned directly under the first cube
					const topIce = iceObjects[0];
					const stackY = topIce.baseY - iceHeight - 0.02; // Stack below with small gap
					
					return { 
						x: topIce.baseX + (Math.random() - 0.5) * 0.05, // Tiny offset for realism
						z: topIce.baseZ + (Math.random() - 0.5) * 0.05, 
						y: Math.max(stackY, LIQUID_BASE_Y + iceHeight * 0.5 + 0.1) // Don't go below glass bottom
					};

				}

			}

			function spawnIce() {

				if (iceObjects.length >= iceConfig.maxQuantity) return;

				const size = getCurrentIceSize();
				const iceIndex = iceObjects.length;
				const position = findNonOverlappingPosition(size, iceIndex);

				// First ice cube is the "surface" ice
				const isFirstIce = iceIndex === 0;
				
				// Use GLB model for all ice cubes if available, otherwise use procedural mesh
				let mesh;
				if (iceCubeGLBModel) {
					// Clone the GLB model for this ice cube
					mesh = iceCubeGLBModel.clone();
					
					// Calculate scale to match procedural ice cube size
					// Procedural ice cube dimensions: size * 1.8 (width/depth), size * 2.2 (height)
					// We need to get the bounding box of the GLB model and scale accordingly
					const box = new THREE.Box3().setFromObject(mesh);
					const glbSize = box.getSize(new THREE.Vector3());
					
					// Target size for ice cube
					const targetWidth = size * 1.8;
					const targetHeight = size * 2.2;
					
					// Scale to match target dimensions (use the larger dimension to maintain aspect ratio)
					const scaleX = targetWidth / Math.max(glbSize.x, 0.001);
					const scaleY = targetHeight / Math.max(glbSize.y, 0.001);
					const scaleZ = targetWidth / Math.max(glbSize.z, 0.001);
					
					// Use average scale to maintain proportions, or use the dominant dimension
					const avgScale = (scaleX + scaleY + scaleZ) / 3;
					mesh.scale.set(avgScale, avgScale, avgScale);
					
					// Ensure all meshes in the GLB have proper settings and apply ice material
					mesh.traverse((child) => {
						if (child.isMesh) {
							child.castShadow = true;
							child.receiveShadow = true;
							child.renderOrder = 3;
							
							// Apply ice material with transmission properties
							if (child.material) {
								// Convert to MeshPhysicalMaterial if not already
								if (!(child.material instanceof THREE.MeshPhysicalMaterial)) {
													const iceMat = new THREE.MeshPhysicalMaterial({
														color: child.material.color || 0xd8e4f0,
														metalness: child.material.metalness !== undefined ? child.material.metalness : 0.0,
														roughness: child.material.roughness !== undefined ? child.material.roughness : 0.1,
														transmission: 0.7,
														opacity: 0.85,
														transparent: true,
														thickness: 0.3,
														ior: 1.31,
														clearcoat: 0.8,
														clearcoatRoughness: 0.2,
														envMapIntensity: child.material.envMapIntensity || 1.2,
														side: child.material.side || THREE.FrontSide,
														depthWrite: true,
													});
									child.material = iceMat;
								} else {
									// Update existing MeshPhysicalMaterial with ice defaults
									if (child.material.transmission === undefined) child.material.transmission = 0.9;
									if (child.material.ior === undefined) child.material.ior = 1.31;
									if (child.material.thickness === undefined) child.material.thickness = 0.5;
									if (child.material.clearcoat === undefined) child.material.clearcoat = 1.0;
									if (child.material.clearcoatRoughness === undefined) child.material.clearcoatRoughness = 0.1;
									child.material.depthWrite = false;
								}
								
								// Store material reference for GUI controls (use first mesh material)
								if (!iceCubeMaterial) {
									iceCubeMaterial = child.material;
								}
							}
						}
					});
					
					mesh.renderOrder = 3;
					mesh.userData.baseSize = size;
					mesh.userData.isProcedural = false;
				} else {
					// Use procedural mesh if GLB not loaded yet
					mesh = createIceMesh(size);
				}

				// Each ice cube gets unique animation parameters
				const iceData = {
					mesh,
					baseX: position.x,
					baseY: position.y,
					baseZ: position.z,
					targetY: position.y,
					isFloater: isFirstIce,
					velocityY: 0,
					phaseX: Math.random() * Math.PI * 2,
					phaseZ: Math.random() * Math.PI * 2,
					phaseY: Math.random() * Math.PI * 2,
					rotationSpeed: (Math.random() - 0.5) * 0.3,
					bobSpeed: 0.8 + Math.random() * 0.4,
					bobAmount: isFirstIce ? 0.02 : 0.01,
					driftAmount: 0.01 + Math.random() * 0.01,
				};

				mesh.position.set(
					iceData.baseX,
					iceData.baseY,
					iceData.baseZ
				);

				mesh.rotation.set(
					Math.random() * 0.3,
					Math.random() * Math.PI * 2,
					Math.random() * 0.3
				);

				scene.add(mesh);
				iceObjects.push(iceData);

			}

			function removeIce() {

				if (iceObjects.length === 0) return;

				const ice = iceObjects.pop();
				scene.remove(ice.mesh);
				ice.mesh.geometry.dispose();
				ice.mesh.material.dispose();

			}


			function getIceCollisionRadius(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Use the larger dimension (1.8 * size * scale) as collision radius
				return size * 1.8 * scale * 0.5;

			}

			function resolveIceCollisions() {

				const size = getCurrentIceSize();
				const iceHeight = size * 2.2;
				const minY = LIQUID_BASE_Y + iceHeight * 0.5 + 0.05;
				const boundsRadius = LIQUID_RADIUS - size * 0.8;

				// For 2 stacked cubes - maintain vertical alignment
				if (iceObjects.length === 2) {

					const topIce = iceObjects[0];  // First ice (floater at top)
					const bottomIce = iceObjects[1];  // Second ice (below)

					// Keep top ice at surface level
					const topTargetY = LIQUID_SURFACE_Y - iceHeight * 0.35;
					topIce.baseY += (topTargetY - topIce.baseY) * 0.1;

					// Keep bottom ice stacked below top ice
					const bottomTargetY = topIce.baseY - iceHeight - 0.02;
					const clampedBottomY = Math.max(bottomTargetY, minY);
					bottomIce.baseY += (clampedBottomY - bottomIce.baseY) * 0.1;

					// Keep bottom ice horizontally aligned with top (slight offset for realism)
					bottomIce.baseX += (topIce.baseX - bottomIce.baseX) * 0.05;
					bottomIce.baseZ += (topIce.baseZ - bottomIce.baseZ) * 0.05;

				}

				// Apply bounds constraints for all ice
				for (const ice of iceObjects) {

					// Keep within glass bounds horizontally
					const currentDist = Math.sqrt(ice.baseX * ice.baseX + ice.baseZ * ice.baseZ);
					if (currentDist > boundsRadius) {

						const scale = boundsRadius / currentDist;
						ice.baseX *= scale;
						ice.baseZ *= scale;

					}

					// Clamp Y range
					const maxY = ice.isFloater 
						? LIQUID_SURFACE_Y - iceHeight * 0.25 
						: LIQUID_SURFACE_Y - iceHeight * 0.6;
					
					if (ice.baseY > maxY) ice.baseY = maxY;
					if (ice.baseY < minY) ice.baseY = minY;

				}

			}

			function updateIceAnimation(time) {

				const size = getCurrentIceSize();
				const boundsRadius = LIQUID_RADIUS - size * 1.0;

				// Resolve collisions (iterations are inside the function)
				resolveIceCollisions();

				for (const ice of iceObjects) {

					// Gentle bobbing motion - stronger for floater
					const bobY = Math.sin(time * ice.bobSpeed + ice.phaseY) * ice.bobAmount;

					// Slight drift in X and Z
					const driftX = Math.sin(time * 0.3 + ice.phaseX) * ice.driftAmount;
					const driftZ = Math.cos(time * 0.25 + ice.phaseZ) * ice.driftAmount;

					// Apply position from base + drift
					let newX = ice.baseX + driftX;
					let newZ = ice.baseZ + driftZ;

					// Final boundary check
					const dist = Math.sqrt(newX * newX + newZ * newZ);

					if (dist > boundsRadius) {

						const boundsScale = boundsRadius / dist;
						newX *= boundsScale;
						newZ *= boundsScale;

					}

					ice.mesh.position.x = newX;
					ice.mesh.position.y = ice.baseY + bobY;
					ice.mesh.position.z = newZ;

					// Gentle rotation
					ice.mesh.rotation.y += ice.rotationSpeed * 0.016;
					ice.mesh.rotation.x = Math.sin(time * 0.5 + ice.phaseX) * 0.06;
					ice.mesh.rotation.z = Math.cos(time * 0.4 + ice.phaseZ) * 0.06;

				}

			}

			// Orange peel creation (single strip peel)
			function createOrangeSlice() {

				const group = new THREE.Group();

				// Peel dimensions - shorter strip (half length)
				const peelLength = 1.2;
				const peelWidth = 0.18;
				const peelThickness = 0.035;
				const curveSegments = 16;

				// Create a curved path for the peel - gentle S-curve
				const curve = new THREE.CatmullRomCurve3([
					new THREE.Vector3(0, 0, 0),
					new THREE.Vector3(0.06, peelLength * 0.3, 0.03),
					new THREE.Vector3(-0.04, peelLength * 0.6, 0.05),
					new THREE.Vector3(0.02, peelLength, 0),
				]);

				// Create custom peel geometry by extruding along curve
				const peelShape = new THREE.Shape();
				peelShape.moveTo(-peelWidth / 2, 0);
				peelShape.lineTo(peelWidth / 2, 0);
				peelShape.lineTo(peelWidth / 2, peelThickness);
				peelShape.lineTo(-peelWidth / 2, peelThickness);
				peelShape.lineTo(-peelWidth / 2, 0);

				const extrudeSettings = {
					steps: curveSegments,
					bevelEnabled: false,
					extrudePath: curve,
				};

				const peelGeometry = new THREE.ExtrudeGeometry(peelShape, extrudeSettings);

				// Orange rind (outer surface) - vibrant orange
				const rindMaterial = new THREE.MeshStandardMaterial({
					color: 0xf57c00,
					metalness: 0.05,
					roughness: 0.55,
					side: THREE.FrontSide,
				});

				const peel = new THREE.Mesh(peelGeometry, rindMaterial);
				group.add(peel);

				// Inner pith layer (whitish-orange)
				const pithGeometry = peelGeometry.clone();
				const pithMaterial = new THREE.MeshStandardMaterial({
					color: 0xffe4b5,
					metalness: 0.0,
					roughness: 0.85,
					side: THREE.BackSide,
				});

				const pith = new THREE.Mesh(pithGeometry, pithMaterial);
				group.add(pith);

				// Add subtle texture detail with slight bumps along the peel
				const detailCount = 6;
				const detailMaterial = new THREE.MeshStandardMaterial({
					color: 0xd46a00,
					metalness: 0.0,
					roughness: 0.7,
				});

				for (let i = 0; i < detailCount; i++) {

					const t = (i + 0.5) / detailCount;
					const point = curve.getPoint(t);

					// Small bumps for orange peel texture
					const bumpGeo = new THREE.SphereGeometry(0.012, 6, 6);
					const bump = new THREE.Mesh(bumpGeo, detailMaterial);

					// Offset slightly from center
					const offsetX = (Math.random() - 0.5) * peelWidth * 0.5;
					const offsetZ = peelThickness * 0.5;

					bump.position.set(
						point.x + offsetX,
						point.y,
						point.z + offsetZ
					);

					group.add(bump);

				}

				return group;

			}

			function spawnOrangeSlice() {

				orangeSlice = createOrangeSlice();
				
				// Position inside glass at top, vertical orientation
				// Leaning slightly against the inner glass wall
				const peelX = 0.45;  // Near the inner edge of glass
				const peelZ = 0.3;
				const peelY = LIQUID_SURFACE_Y - 0.5;  // Bottom in liquid, top sticks out
				
				orangeSlice.position.set(peelX, peelY, peelZ);
				
				// Rotate to be vertical with slight lean toward glass edge
				orangeSlice.rotation.x = 0;  // Upright
				orangeSlice.rotation.y = -Math.PI * 0.3;  // Angled view
				orangeSlice.rotation.z = Math.PI * 0.12;  // Slight lean against glass
				
				orangeSlice.renderOrder = 6;
				orangeSlice.visible = orangeSliceVisible;
				scene.add(orangeSlice);

			}

			function updateOrangeSliceAnimation(time) {

				if (!orangeSlice || !orangeSliceVisible) return;

				// Very subtle movement - peel is resting against inner glass wall
				const gentleSway = Math.sin(time * 0.4) * 0.005;
				const subtleBob = Math.sin(time * 0.6) * 0.008;

				// Base position with subtle animation
				const peelX = 0.45;
				const peelZ = 0.3;
				const peelY = LIQUID_SURFACE_Y - 0.5;
				
				orangeSlice.position.x = peelX + gentleSway;
				orangeSlice.position.y = peelY + subtleBob;
				orangeSlice.position.z = peelZ + gentleSway * 0.3;

				// Very subtle rotation sway
				orangeSlice.rotation.z = Math.PI * 0.12 + Math.sin(time * 0.3) * 0.015;

			}

		function toggleOrangeSlice(visible) {

			orangeSliceVisible = visible;

			if (orangeSlice) {

				orangeSlice.visible = visible;

			}

		}

		// Load cube.glb model
		function loadCubeModel() {

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

			const gltfLoader = new GLTFLoader();
			gltfLoader.setDRACOLoader(dracoLoader);

			gltfLoader.load(
				'models/glb/glass-01.glb',
				(gltf) => {

				cubeModel = gltf.scene;

				// Use 1:1 scale - no auto-scaling or centering
				// Model position and scale from Blender will be used directly
				cubeModel.scale.set(1, 1, 1);

				// Apply realistic glass material using transmission (not just opacity)
			cubeModel.traverse((child) => {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
					
				// Use MeshPhysicalMaterial for realistic glass with refraction
				glassModelMaterial = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0.2,          // Glass is not metallic
					roughness: 0,       // Very smooth surface
					transmission: 0.95,    // HIGH transmission = see-through with refraction (NOT opacity!)
					opacity: 1,            // Keep at 1 when using transmission
					transparent: true,
					thickness: 0,        // Glass thickness for refraction calculation
					clearcoat: 1.0,        // Glossy clear coat layer
					clearcoatRoughness: 0, // Perfectly smooth clear coat
					ior: 1.5,              // Index of refraction for glass
					envMapIntensity: 1.3,  // Environment reflections
					side: THREE.FrontSide, // Render front side only
					depthWrite: false,     // Important for transparency sorting
				});
				
				child.material = glassModelMaterial;
				}
			});

			// Position in the scene - centered at origin
			const container = new THREE.Group();
			container.add(cubeModel);
			container.position.set(0, 0, 0); // Centered at world origin
			container.renderOrder = 5;

			scene.add(container);

			console.log('Cube model loaded successfully at 1:1 scale');

			// Create glass material GUI controls now that material is available
			if (gui && glassModelMaterial) {
				createGlassGUI(gui);
			}

				},
				(progress) => {

					console.log('Loading cube:', (progress.loaded / progress.total * 100) + '%');

				},
				(error) => {

					console.error('Error loading cube model:', error);

				}
			);

		}

		// Load floor-01.glb model
		function loadFloorModel() {

			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

			const gltfLoader = new GLTFLoader();
			gltfLoader.setDRACOLoader(dracoLoader);

			gltfLoader.load(
				'models/glb/floor-01.glb',
				(gltf) => {

				floorModel = gltf.scene;

				// Use 1:1 scale - no auto-scaling or centering
				// Model position and scale from Blender will be used directly
				floorModel.scale.set(1, 1, 1);

				// Ensure all meshes in the model have proper settings
				floorModel.traverse((child) => {
					if (child.isMesh) {
						child.castShadow = true;
						child.receiveShadow = true;
					}
				});

				// Position in the scene - centered at origin
				const container = new THREE.Group();
				container.add(floorModel);
				container.position.set(0, 0, 0); // Centered at world origin
				container.renderOrder = 0; // Render before other objects

				scene.add(container);

				console.log('Floor model loaded successfully at 1:1 scale');

			},
			(progress) => {

				console.log('Loading floor:', (progress.loaded / progress.total * 100) + '%');

			},
			(error) => {

				console.error('Error loading floor model:', error);

			}
		);

		}

			// Hotspot creation
			function createHotspot(position, label, panelId, color = 0x7ec8e8) {

				const group = new THREE.Group();
				group.position.copy(position);

				// Inner pulsing dot
				const dotGeometry = new THREE.SphereGeometry(0.06, 16, 16);
				const dotMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.9,
				});
				const dot = new THREE.Mesh(dotGeometry, dotMaterial);
				group.add(dot);

				// Outer ring
				const ringGeometry = new THREE.RingGeometry(0.1, 0.14, 32);
				const ringMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.6,
					side: THREE.DoubleSide,
				});
				const ring = new THREE.Mesh(ringGeometry, ringMaterial);
				ring.lookAt(camera.position);
				group.add(ring);

				// Pulse ring (animated)
				const pulseGeometry = new THREE.RingGeometry(0.08, 0.1, 32);
				const pulseMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.5,
					side: THREE.DoubleSide,
				});
				const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial);
				pulseRing.lookAt(camera.position);
				group.add(pulseRing);

				group.userData = {
					label: label,
					panelId: panelId,
					dot: dot,
					ring: ring,
					pulseRing: pulseRing,
					baseScale: 1,
					hovered: false,
				};

				scene.add(group);
				hotspots.push(group);

				return group;

			}

			function initHotspots() {

				// Whisky hotspot - at the liquid level
				createHotspot(
					new THREE.Vector3(0.9, 1.5, 0.4),
					'About Toki Whisky',
					'panelWhisky',
					0xdbb85c
				);

				// Ice hotspot - near the ice cubes
				createHotspot(
					new THREE.Vector3(-0.5, 2.2, 0.7),
					'The Perfect Ice',
					'panelIce',
					0xaaddff
				);

				// Glass hotspot - on the glass rim
				createHotspot(
					new THREE.Vector3(0.6, 2.8, -0.5),
					'Highball Glass',
					'panelGlass',
					0x7ec8e8
				);

				// Video hotspot - near the base
				createHotspot(
					new THREE.Vector3(-0.8, 0.6, -0.6),
					'Watch the Ritual',
					'panelVideo',
					0xff9f43
				);

			}

			function updateHotspots(time) {

				for (const hotspot of hotspots) {

					const { ring, pulseRing, hovered } = hotspot.userData;

					// Make rings face camera
					ring.lookAt(camera.position);
					pulseRing.lookAt(camera.position);

					// Pulse animation
					const pulse = 1 + Math.sin(time * 3) * 0.15;
					pulseRing.scale.set(pulse, pulse, pulse);
					pulseRing.material.opacity = 0.5 * (1 - (pulse - 1) / 0.15 * 0.5);

					// Hover effect
					const targetScale = hovered ? 1.3 : 1;
					hotspot.userData.baseScale += (targetScale - hotspot.userData.baseScale) * 0.1;
					hotspot.scale.setScalar(hotspot.userData.baseScale);

				}

			}

			function checkHotspotHover() {

				raycaster.setFromCamera(mouse, camera);

				let foundHover = false;

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						hotspot.userData.hovered = true;
						foundHover = true;

						// Show label
						const screenPos = hotspot.position.clone().project(camera);
						const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
						const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

						hotspotLabel.textContent = hotspot.userData.label;
						hotspotLabel.style.left = x + 'px';
						hotspotLabel.style.top = (y - 50) + 'px';
						hotspotLabel.classList.add('visible');

						renderer.domElement.style.cursor = 'pointer';

					} else {

						hotspot.userData.hovered = false;

					}

				}

				if (!foundHover) {

					hotspotLabel.classList.remove('visible');
					renderer.domElement.style.cursor = 'grab';

				}

			}

			function checkHotspotClick() {

				raycaster.setFromCamera(mouse, camera);

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						openPanel(hotspot.userData.panelId);
						return true;

					}

				}

				return false;

			}

			function openPanel(panelId) {

				// Close any open panel first
				closePanel();

				const panel = document.getElementById(panelId);
				if (panel) {

					activePanel = panel;
					panel.classList.add('active');
					hotspotOverlay.classList.add('active');
					hotspotLabel.classList.remove('visible');

					// Focus trap for accessibility
					const closeBtn = panel.querySelector('.hotspot-panel-close');
					if (closeBtn) closeBtn.focus();

				}

			}

			function closePanel() {

				if (activePanel) {

					activePanel.classList.remove('active');
					activePanel = null;

				}

				hotspotOverlay.classList.remove('active');

			}

			function setupPanelControls() {

				// Close buttons
				document.querySelectorAll('.hotspot-panel-close').forEach(btn => {

					btn.addEventListener('click', closePanel);
					btn.addEventListener('keydown', (e) => {

						if (e.key === 'Enter' || e.key === ' ') {

							e.preventDefault();
							closePanel();

						}

					});

				});

				// Overlay click to close
				hotspotOverlay.addEventListener('click', closePanel);

			// Escape key to close
			document.addEventListener('keydown', (e) => {

				if (e.key === 'Escape' && activePanel) {

					closePanel();

				}

			// 'G' key to toggle glass
			if (e.key === 'g' || e.key === 'G') {

				window.toggleGlass();

			}

			// 'H' key to toggle light helpers
			if (e.key === 'h' || e.key === 'H') {

				if (lights && lights.helpers && lights.helpers.length > 0) {
					const currentVisibility = lights.helpers[0].visible;
					toggleHelpers(lights, !currentVisibility);
				}

			}

			// 'T' key to set gizmo to translate mode
			if (e.key === 't' || e.key === 'T') {

				if (transformControls) {
					transformControls.setMode('translate');
					console.log('Gizmo mode: translate');
				}

			}

			// 'R' key to set gizmo to rotate mode
			if (e.key === 'r' || e.key === 'R') {

				if (transformControls) {
					transformControls.setMode('rotate');
					console.log('Gizmo mode: rotate');
				}

			}

			// 'S' key to set gizmo to scale mode
			if (e.key === 's' || e.key === 'S') {

				if (transformControls) {
					transformControls.setMode('scale');
					console.log('Gizmo mode: scale');
				}

			}

			// 'D' key to detach gizmo
			if (e.key === 'd' || e.key === 'D') {

				if (transformControls) {
					transformControls.detach();
					console.log('Gizmo detached');
				}

			}

			});

			}

			// Bubble system
			function initBubbleSystem() {

				bubbleGeometry = new THREE.SphereGeometry(0.012, 8, 8);
				bubbleMaterial = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					metalness: 0.0,
					roughness: 0.2,
					transparent: true,
					opacity: 0.6,
					emissive: 0xffeedd,
					emissiveIntensity: 0.1,
				});

				bubbleMesh = new THREE.InstancedMesh(bubbleGeometry, bubbleMaterial, MAX_BUBBLES);
				bubbleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
				bubbleMesh.renderOrder = 4;
				scene.add(bubbleMesh);

				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleInstances.push({
						active: false,
						position: new THREE.Vector3(),
						velocity: new THREE.Vector3(),
						size: 1,
						life: 0,
						maxLife: 0,
					});

				}

				const matrix = new THREE.Matrix4();
				matrix.makeScale(0, 0, 0);
				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleMesh.setMatrixAt(i, matrix);

				}
				bubbleMesh.instanceMatrix.needsUpdate = true;

			}

			function spawnBubble() {

				const bubble = bubbleInstances.find(b => !b.active);
				if (!bubble) return;

				const angle = Math.random() * Math.PI * 2;
				const radius = Math.random() * (LIQUID_RADIUS - 0.1);

				bubble.position.set(
					Math.cos(angle) * radius,
					LIQUID_BASE_Y + 0.05,
					Math.sin(angle) * radius
				);

				bubble.velocity.set(
					(Math.random() - 0.5) * 0.02,
					0.3 + Math.random() * 0.4,
					(Math.random() - 0.5) * 0.02
				);

				bubble.size = 0.5 + Math.random() * 1.0;
				bubble.life = 0;
				bubble.maxLife = 2 + Math.random() * 3;
				bubble.active = true;

			}

			function updateBubbles(deltaTime) {

				const spawnRate = fizzIntensity * 30;
				const spawnChance = spawnRate * deltaTime;

				if (Math.random() < spawnChance) {

					spawnBubble();

				}

				const matrix = new THREE.Matrix4();
				const position = new THREE.Vector3();
				const quaternion = new THREE.Quaternion();
				const scale = new THREE.Vector3();

				for (let i = 0; i < bubbleInstances.length; i++) {

					const bubble = bubbleInstances[i];

					if (!bubble.active) {

						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					bubble.life += deltaTime;

					if (bubble.life > bubble.maxLife || bubble.position.y > LIQUID_SURFACE_Y) {

						bubble.active = false;
						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					// Add slight wobble
					bubble.velocity.x += (Math.random() - 0.5) * 0.05;
					bubble.velocity.z += (Math.random() - 0.5) * 0.05;

					bubble.position.x += bubble.velocity.x * deltaTime;
					bubble.position.y += bubble.velocity.y * deltaTime;
					bubble.position.z += bubble.velocity.z * deltaTime;

					const dist = Math.sqrt(
						bubble.position.x * bubble.position.x +
						bubble.position.z * bubble.position.z
					);

					if (dist > LIQUID_RADIUS - 0.05) {

						bubble.position.x *= (LIQUID_RADIUS - 0.05) / dist;
						bubble.position.z *= (LIQUID_RADIUS - 0.05) / dist;

					}

					const lifeRatio = bubble.life / bubble.maxLife;
					let sizeMultiplier = 1;

					if (lifeRatio < 0.1) {

						sizeMultiplier = lifeRatio / 0.1;

					} else if (lifeRatio > 0.9) {

						sizeMultiplier = (1 - lifeRatio) / 0.1;

					}

					const finalSize = bubble.size * sizeMultiplier;
					scale.set(finalSize, finalSize, finalSize);
					matrix.compose(bubble.position, quaternion, scale);
					bubbleMesh.setMatrixAt(i, matrix);

				}

				bubbleMesh.instanceMatrix.needsUpdate = true;

		}

		// Create floor GUI controls
		function createFloorGUI(gui) {
			if (!floor || !floor.material) return;

			const floorFolder = gui.addFolder('Floor');
			
			const floorSettings = {
				color: '#' + floor.material.color.getHexString(),
				roughness: floor.material.roughness,
				metalness: floor.material.metalness,
				envMapIntensity: floor.material.envMapIntensity,
				visible: floor.visible,
			};

			// Color control
			floorFolder.addColor(floorSettings, 'color').name('Color').onChange((value) => {
				floor.material.color.set(value);
			});

			// Roughness control
			floorFolder.add(floorSettings, 'roughness', 0, 1, 0.01).name('Roughness').onChange((value) => {
				floor.material.roughness = value;
			});

			// Metalness control
			floorFolder.add(floorSettings, 'metalness', 0, 1, 0.01).name('Metalness').onChange((value) => {
				floor.material.metalness = value;
			});

			// Environment map intensity
			floorFolder.add(floorSettings, 'envMapIntensity', 0, 3, 0.1).name('Reflection Intensity').onChange((value) => {
				floor.material.envMapIntensity = value;
			});

			// Visibility toggle
			floorFolder.add(floorSettings, 'visible').name('Visible').onChange((value) => {
				floor.visible = value;
			});

			// Keep folder collapsed by default
			floorFolder.close();
		}

		// Create glass material GUI controls
		function createGlassGUI(gui) {
			if (!glassModelMaterial) return;

			const glassFolder = gui.addFolder('Glass Material');
			
			const glassSettings = {
				color: '#' + glassModelMaterial.color.getHexString(),
				roughness: glassModelMaterial.roughness,
				metalness: glassModelMaterial.metalness,
				transmission: glassModelMaterial.transmission,
				opacity: glassModelMaterial.opacity,
				ior: glassModelMaterial.ior,
				thickness: glassModelMaterial.thickness,
				clearcoat: glassModelMaterial.clearcoat,
				clearcoatRoughness: glassModelMaterial.clearcoatRoughness,
				envMapIntensity: glassModelMaterial.envMapIntensity,
				side: glassModelMaterial.side === THREE.DoubleSide ? 'Double' : 'Front',
				depthWrite: glassModelMaterial.depthWrite,
			};

			// Basic Properties
			const basicFolder = glassFolder.addFolder('Basic');
			basicFolder.addColor(glassSettings, 'color').name('Color').onChange((value) => {
				glassModelMaterial.color.set(value);
			});
			basicFolder.add(glassSettings, 'roughness', 0, 1, 0.01).name('Roughness').onChange((value) => {
				glassModelMaterial.roughness = value;
			});
			basicFolder.add(glassSettings, 'metalness', 0, 1, 0.01).name('Metalness').onChange((value) => {
				glassModelMaterial.metalness = value;
			});
			basicFolder.add(glassSettings, 'opacity', 0, 1, 0.01).name('Opacity').onChange((value) => {
				glassModelMaterial.opacity = value;
			});
			basicFolder.close();

			// Transmission & Refraction
			const transmissionFolder = glassFolder.addFolder('Transmission & Refraction');
			transmissionFolder.add(glassSettings, 'transmission', 0, 1, 0.01).name('Transmission').onChange((value) => {
				glassModelMaterial.transmission = value;
			});
			transmissionFolder.add(glassSettings, 'ior', 1, 2.5, 0.01).name('IOR').onChange((value) => {
				glassModelMaterial.ior = value;
			});
			transmissionFolder.add(glassSettings, 'thickness', 0, 2, 0.1).name('Thickness').onChange((value) => {
				glassModelMaterial.thickness = value;
			});
			transmissionFolder.close();

			// Clearcoat
			const clearcoatFolder = glassFolder.addFolder('Clearcoat');
			clearcoatFolder.add(glassSettings, 'clearcoat', 0, 1, 0.01).name('Clearcoat').onChange((value) => {
				glassModelMaterial.clearcoat = value;
			});
			clearcoatFolder.add(glassSettings, 'clearcoatRoughness', 0, 1, 0.01).name('Clearcoat Roughness').onChange((value) => {
				glassModelMaterial.clearcoatRoughness = value;
			});
			clearcoatFolder.close();

			// Environment & Rendering
			const envFolder = glassFolder.addFolder('Environment & Rendering');
			envFolder.add(glassSettings, 'envMapIntensity', 0, 3, 0.1).name('Reflection Intensity').onChange((value) => {
				glassModelMaterial.envMapIntensity = value;
			});
			envFolder.add(glassSettings, 'side', ['Front', 'Double']).name('Side').onChange((value) => {
				glassModelMaterial.side = value === 'Double' ? THREE.DoubleSide : THREE.FrontSide;
				glassModelMaterial.needsUpdate = true;
			});
			envFolder.add(glassSettings, 'depthWrite').name('Depth Write').onChange((value) => {
				glassModelMaterial.depthWrite = value;
			});
			envFolder.close();

			// Keep folder collapsed by default
			glassFolder.close();
		}

		// Create ice cube material GUI controls
		function createIceCubeGUI(gui) {
			// Get material from first ice cube if available
			if (iceObjects.length > 0 && iceObjects[0].mesh) {
				// Try to get material from GLB model or procedural mesh
				let material = null;
				iceObjects[0].mesh.traverse((child) => {
					if (child.isMesh && child.material && !material) {
						material = child.material;
					}
				});
				
				// Fallback to stored material reference
				if (!material) {
					material = iceCubeMaterial;
				}
				
				if (!material) return;
				
				const iceFolder = gui.addFolder('Ice Cube Material');
				
				const iceSettings = {
					color: '#' + material.color.getHexString(),
					roughness: material.roughness,
					metalness: material.metalness,
					opacity: material.opacity,
					transmission: material.transmission !== undefined ? material.transmission : 0,
					ior: material.ior !== undefined ? material.ior : 1.5,
					thickness: material.thickness !== undefined ? material.thickness : 0,
					clearcoat: material.clearcoat !== undefined ? material.clearcoat : 0,
					clearcoatRoughness: material.clearcoatRoughness !== undefined ? material.clearcoatRoughness : 0,
					envMapIntensity: material.envMapIntensity || 1.0,
					emissive: '#' + (material.emissive ? material.emissive.getHexString() : '000000'),
					emissiveIntensity: material.emissiveIntensity || 0,
					side: material.side === THREE.DoubleSide ? 'Double' : (material.side === THREE.BackSide ? 'Back' : 'Front'),
					depthWrite: material.depthWrite,
					transparent: material.transparent,
				};

				// Basic Properties
				const basicFolder = iceFolder.addFolder('Basic');
				basicFolder.addColor(iceSettings, 'color').name('Color').onChange((value) => {
					// Update all ice cube materials
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.color.set(value));
								} else {
									child.material.color.set(value);
								}
							}
						});
					});
				});
				basicFolder.add(iceSettings, 'roughness', 0, 1, 0.01).name('Roughness').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.roughness = value);
								} else {
									child.material.roughness = value;
								}
							}
						});
					});
				});
				basicFolder.add(iceSettings, 'metalness', 0, 1, 0.01).name('Metalness').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.metalness = value);
								} else {
									child.material.metalness = value;
								}
							}
						});
					});
				});
				basicFolder.add(iceSettings, 'opacity', 0, 1, 0.01).name('Opacity').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.opacity = value);
								} else {
									child.material.opacity = value;
								}
							}
						});
					});
				});
				basicFolder.close();

				// Transmission & Refraction
				const transmissionFolder = iceFolder.addFolder('Transmission & Refraction');
				transmissionFolder.add(iceSettings, 'transmission', 0, 1, 0.01).name('Transmission').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.transmission !== undefined) mat.transmission = value;
									});
								} else {
									if (child.material.transmission !== undefined) child.material.transmission = value;
								}
							}
						});
					});
				});
				transmissionFolder.add(iceSettings, 'ior', 1, 2.5, 0.01).name('IOR').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.ior !== undefined) mat.ior = value;
									});
								} else {
									if (child.material.ior !== undefined) child.material.ior = value;
								}
							}
						});
					});
				});
				transmissionFolder.add(iceSettings, 'thickness', 0, 2, 0.1).name('Thickness').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.thickness !== undefined) mat.thickness = value;
									});
								} else {
									if (child.material.thickness !== undefined) child.material.thickness = value;
								}
							}
						});
					});
				});
				transmissionFolder.close();

				// Clearcoat
				const clearcoatFolder = iceFolder.addFolder('Clearcoat');
				clearcoatFolder.add(iceSettings, 'clearcoat', 0, 1, 0.01).name('Clearcoat').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.clearcoat !== undefined) mat.clearcoat = value;
									});
								} else {
									if (child.material.clearcoat !== undefined) child.material.clearcoat = value;
								}
							}
						});
					});
				});
				clearcoatFolder.add(iceSettings, 'clearcoatRoughness', 0, 1, 0.01).name('Clearcoat Roughness').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.clearcoatRoughness !== undefined) mat.clearcoatRoughness = value;
									});
								} else {
									if (child.material.clearcoatRoughness !== undefined) child.material.clearcoatRoughness = value;
								}
							}
						});
					});
				});
				clearcoatFolder.close();

				// Emissive Properties
				const emissiveFolder = iceFolder.addFolder('Emissive');
				emissiveFolder.addColor(iceSettings, 'emissive').name('Emissive Color').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.emissive) mat.emissive.set(value);
									});
								} else {
									if (child.material.emissive) child.material.emissive.set(value);
								}
							}
						});
					});
				});
				emissiveFolder.add(iceSettings, 'emissiveIntensity', 0, 2, 0.01).name('Emissive Intensity').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.emissiveIntensity !== undefined) mat.emissiveIntensity = value;
									});
								} else {
									if (child.material.emissiveIntensity !== undefined) child.material.emissiveIntensity = value;
								}
							}
						});
					});
				});
				emissiveFolder.close();

				// Environment & Rendering
				const envFolder = iceFolder.addFolder('Environment & Rendering');
				envFolder.add(iceSettings, 'envMapIntensity', 0, 3, 0.1).name('Reflection Intensity').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										if (mat.envMapIntensity !== undefined) mat.envMapIntensity = value;
									});
								} else {
									if (child.material.envMapIntensity !== undefined) child.material.envMapIntensity = value;
								}
							}
						});
					});
				});
				envFolder.add(iceSettings, 'side', ['Front', 'Back', 'Double']).name('Side').onChange((value) => {
					const sideMap = {
						'Front': THREE.FrontSide,
						'Back': THREE.BackSide,
						'Double': THREE.DoubleSide
					};
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => {
										mat.side = sideMap[value];
										mat.needsUpdate = true;
									});
								} else {
									child.material.side = sideMap[value];
									child.material.needsUpdate = true;
								}
							}
						});
					});
				});
				envFolder.add(iceSettings, 'depthWrite').name('Depth Write').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.depthWrite = value);
								} else {
									child.material.depthWrite = value;
								}
							}
						});
					});
				});
				envFolder.add(iceSettings, 'transparent').name('Transparent').onChange((value) => {
					iceObjects.forEach((ice) => {
						ice.mesh.traverse((child) => {
							if (child.isMesh && child.material) {
								if (Array.isArray(child.material)) {
									child.material.forEach(mat => mat.transparent = value);
								} else {
									child.material.transparent = value;
								}
							}
						});
					});
				});
				envFolder.close();

				// Keep folder collapsed by default
				iceFolder.close();
			}
		}

		// Create liquid material GUI controls
		function createLiquidGUI(gui) {
			if (!liquidSurface || !liquidBody || !liquidSurface.material || !liquidBody.material) return;

			const liquidFolder = gui.addFolder('Liquid Material');
			
			// Surface Material Settings
			const surfaceFolder = liquidFolder.addFolder('Surface (Top Circle)');
			const surfaceSettings = {
				color: '#' + liquidSurface.material.color.getHexString(),
				roughness: liquidSurface.material.roughness,
				metalness: liquidSurface.material.metalness,
				opacity: liquidSurface.material.opacity,
				emissive: '#' + (liquidSurface.material.emissive ? liquidSurface.material.emissive.getHexString() : '000000'),
				emissiveIntensity: liquidSurface.material.emissiveIntensity || 0,
				envMapIntensity: liquidSurface.material.envMapIntensity || 1.0,
				side: liquidSurface.material.side === THREE.DoubleSide ? 'Double' : (liquidSurface.material.side === THREE.BackSide ? 'Back' : 'Front'),
				depthWrite: liquidSurface.material.depthWrite,
				transparent: liquidSurface.material.transparent,
			};

			surfaceFolder.addColor(surfaceSettings, 'color').name('Color').onChange((value) => {
				liquidSurface.material.color.set(value);
			});
			surfaceFolder.add(surfaceSettings, 'roughness', 0, 1, 0.01).name('Roughness').onChange((value) => {
				liquidSurface.material.roughness = value;
			});
			surfaceFolder.add(surfaceSettings, 'metalness', 0, 1, 0.01).name('Metalness').onChange((value) => {
				liquidSurface.material.metalness = value;
			});
			surfaceFolder.add(surfaceSettings, 'opacity', 0, 1, 0.01).name('Opacity').onChange((value) => {
				liquidSurface.material.opacity = value;
			});
			surfaceFolder.addColor(surfaceSettings, 'emissive').name('Emissive Color').onChange((value) => {
				if (liquidSurface.material.emissive) liquidSurface.material.emissive.set(value);
			});
			surfaceFolder.add(surfaceSettings, 'emissiveIntensity', 0, 2, 0.01).name('Emissive Intensity').onChange((value) => {
				if (liquidSurface.material.emissiveIntensity !== undefined) liquidSurface.material.emissiveIntensity = value;
			});
			surfaceFolder.add(surfaceSettings, 'envMapIntensity', 0, 3, 0.1).name('Reflection Intensity').onChange((value) => {
				if (liquidSurface.material.envMapIntensity !== undefined) liquidSurface.material.envMapIntensity = value;
			});
			surfaceFolder.add(surfaceSettings, 'side', ['Front', 'Back', 'Double']).name('Side').onChange((value) => {
				const sideMap = {
					'Front': THREE.FrontSide,
					'Back': THREE.BackSide,
					'Double': THREE.DoubleSide
				};
				liquidSurface.material.side = sideMap[value];
				liquidSurface.material.needsUpdate = true;
			});
			surfaceFolder.add(surfaceSettings, 'depthWrite').name('Depth Write').onChange((value) => {
				liquidSurface.material.depthWrite = value;
			});
			surfaceFolder.add(surfaceSettings, 'transparent').name('Transparent').onChange((value) => {
				liquidSurface.material.transparent = value;
			});
			surfaceFolder.close();

			// Body Material Settings (Cylinder)
			const bodyFolder = liquidFolder.addFolder('Body (Cylinder)');
			const bodySettings = {
				color: '#' + liquidBody.material.color.getHexString(),
				roughness: liquidBody.material.roughness,
				metalness: liquidBody.material.metalness,
				opacity: liquidBody.material.opacity,
				emissive: '#' + (liquidBody.material.emissive ? liquidBody.material.emissive.getHexString() : '000000'),
				emissiveIntensity: liquidBody.material.emissiveIntensity || 0,
				envMapIntensity: liquidBody.material.envMapIntensity || 1.0,
				side: liquidBody.material.side === THREE.DoubleSide ? 'Double' : (liquidBody.material.side === THREE.BackSide ? 'Back' : 'Front'),
				depthWrite: liquidBody.material.depthWrite,
				transparent: liquidBody.material.transparent,
			};

			bodyFolder.addColor(bodySettings, 'color').name('Color').onChange((value) => {
				liquidBody.material.color.set(value);
			});
			bodyFolder.add(bodySettings, 'roughness', 0, 1, 0.01).name('Roughness').onChange((value) => {
				liquidBody.material.roughness = value;
			});
			bodyFolder.add(bodySettings, 'metalness', 0, 1, 0.01).name('Metalness').onChange((value) => {
				liquidBody.material.metalness = value;
			});
			bodyFolder.add(bodySettings, 'opacity', 0, 1, 0.01).name('Opacity').onChange((value) => {
				liquidBody.material.opacity = value;
			});
			bodyFolder.addColor(bodySettings, 'emissive').name('Emissive Color').onChange((value) => {
				if (liquidBody.material.emissive) liquidBody.material.emissive.set(value);
			});
			bodyFolder.add(bodySettings, 'emissiveIntensity', 0, 2, 0.01).name('Emissive Intensity').onChange((value) => {
				if (liquidBody.material.emissiveIntensity !== undefined) liquidBody.material.emissiveIntensity = value;
			});
			bodyFolder.add(bodySettings, 'envMapIntensity', 0, 3, 0.1).name('Reflection Intensity').onChange((value) => {
				if (liquidBody.material.envMapIntensity !== undefined) liquidBody.material.envMapIntensity = value;
			});
			bodyFolder.add(bodySettings, 'side', ['Front', 'Back', 'Double']).name('Side').onChange((value) => {
				const sideMap = {
					'Front': THREE.FrontSide,
					'Back': THREE.BackSide,
					'Double': THREE.DoubleSide
				};
				liquidBody.material.side = sideMap[value];
				liquidBody.material.needsUpdate = true;
			});
			bodyFolder.add(bodySettings, 'depthWrite').name('Depth Write').onChange((value) => {
				liquidBody.material.depthWrite = value;
			});
			bodyFolder.add(bodySettings, 'transparent').name('Transparent').onChange((value) => {
				liquidBody.material.transparent = value;
			});
			bodyFolder.close();

			// Keep folder collapsed by default
			liquidFolder.close();
		}

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputColorSpace = THREE.SRGBColorSpace;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.1;
				document.body.appendChild(renderer.domElement);

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0a0a0a); // Pretty black (very dark gray)

			// Load HDR environment map
			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			pmremGenerator.compileEquirectangularShader();

			const rgbeLoader = new RGBELoader();
			rgbeLoader.setPath('./textures/');
			rgbeLoader.load('hdr_500.hdr', (texture) => {
				const envMap = pmremGenerator.fromEquirectangular(texture).texture;
				scene.environment = envMap; // Use HDR for reflections only
				scene.background = new THREE.Color(0x0a0a0a); // Pretty black (very dark gray)
				
				texture.dispose();
				pmremGenerator.dispose();
				
				console.log('HDR environment map loaded: hdr_500.hdr (reflections only)');
			}, undefined, (error) => {
				console.error('Error loading HDR environment map:', error);
				console.log('Falling back to simple environment...');
				
				// Fallback to simple environment if HDR fails
				const envScene = new THREE.Scene();
				envScene.background = new THREE.Color(0xaaddff);
				const envGeo = new THREE.SphereGeometry(50, 32, 32);
				const envMat = new THREE.MeshBasicMaterial({
					color: 0xeef6ff,
					side: THREE.BackSide,
				});
				const envMesh = new THREE.Mesh(envGeo, envMat);
				envScene.add(envMesh);
				const envMap = pmremGenerator.fromScene(envScene).texture;
				scene.environment = envMap;
				pmremGenerator.dispose();
			});

			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
			// Start zoomed out to max distance
			camera.position.set(0, 3.5, 8);
			camera.lookAt(0, 1.2, 0);

			// Setup lights from config file
			lights = setupLights(scene);
			console.log('Lights configured from lights-config.js');

			// Default floor removed - using floor-01.glb model instead

				buildLiquid();
				buildGlass();
				initBubbleSystem();

				// Spawn initial ice
				for (let i = 0; i < iceConfig.quantity; i++) {

					spawnIce();

				}

			// Spawn orange slice
			spawnOrangeSlice();
			
			// Create ice cube material GUI controls after ice cubes are spawned
			if (gui && iceObjects.length > 0) {
				createIceCubeGUI(gui);
			}

			// Load cube model
			loadCubeModel();

			// Load floor model
			loadFloorModel();

			// Load ice cube GLB model
			loadIceCubeGLB();

			// Initialize hotspots
			initHotspots();

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.target.set(0, 1.2, 0);
			// Zoom constraints removed - can zoom freely
			// controls.minDistance = 2.5;
			// controls.maxDistance = 8;
			controls.maxPolarAngle = Math.PI * 0.85;

				raycaster = new THREE.Raycaster();
				renderer.domElement.addEventListener('pointermove', onPointerMove);
				renderer.domElement.addEventListener('pointerdown', onPointerDown);

				window.addEventListener('resize', onWindowResize);

			setupControls();
			setupPanelControls();

			// Setup TransformControls for dragging lights
			transformControls = new TransformControls(camera, renderer.domElement);
			transformControls.addEventListener('dragging-changed', (event) => {
				controls.enabled = !event.value; // Disable orbit controls while dragging
			});
			scene.add(transformControls);

			// Setup GUI for light controls
			gui = new GUI({ width: 320 });
			gui.close(); // Start collapsed
			
			// Add floor controls
			createFloorGUI(gui);
			
			// Glass material controls will be added after model loads
			// (createGlassGUI is called in loadCubeModel callback)
			
			// Add liquid material controls (liquid is already built)
			if (liquidSurface && liquidBody) {
				createLiquidGUI(gui);
			}
			
			// Add light controls
			createLightGUI(gui, lights, scene, transformControls);

			renderer.setAnimationLoop(animate);

			}

			function buildGlass() {

				// Outer glass cylinder
				const outerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS,
					GLASS_RADIUS * 0.92,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialOuter = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 1,
					opacity: 1,
					transparent: true,
					thickness: 1,
					clearcoat: 1.0,
					ior: 1.52,
					envMapIntensity: 1.2,
					depthWrite: false,
				});

			glassOuter = new THREE.Mesh(outerGeometry, glassMaterialOuter);
			glassOuter.position.y = GLASS_HEIGHT / 2 + 0.1;
			glassOuter.renderOrder = 10;
			glassOuter.visible = false; // Hidden by default
			scene.add(glassOuter);

				// Inner glass surface
				const innerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS - GLASS_THICKNESS,
					(GLASS_RADIUS * 0.92) - GLASS_THICKNESS,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialInner = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 0.97,
					opacity: 1,
					transparent: true,
					thickness: 0.08,
					clearcoat: 1.0,
					ior: 1.52,
					side: THREE.BackSide,
					depthWrite: false,
				});

			glassInner = new THREE.Mesh(innerGeometry, glassMaterialInner);
			glassInner.position.y = GLASS_HEIGHT / 2 + 0.1;
			glassInner.renderOrder = 9;
			glassInner.visible = false; // Hidden by default
			scene.add(glassInner);

				// Glass bottom
				const bottomGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS * 0.92,
					GLASS_RADIUS * 0.92,
					0.12,
					64
				);
				const bottomMaterial = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.05,
					transmission: 0.9,
					transparent: true,
					thickness: 0.12,
					ior: 1.52,
					depthWrite: false,
				});

			glassBottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
			glassBottom.position.y = 0.06;
			glassBottom.renderOrder = 8;
			glassBottom.visible = false; // Hidden by default
			scene.add(glassBottom);

		}

		// Toggle glass visibility (call from console: toggleGlass())
		window.toggleGlass = function() {
			const isVisible = glassOuter.visible;
			glassOuter.visible = !isVisible;
			glassInner.visible = !isVisible;
			glassBottom.visible = !isVisible;
			console.log('Glass', isVisible ? 'hidden' : 'visible');
		};

		// Toggle light helpers visibility (call from console: toggleLightHelpers())
		window.toggleLightHelpers = function() {
			if (lights && lights.helpers && lights.helpers.length > 0) {
				const currentVisibility = lights.helpers[0].visible;
				toggleHelpers(lights, !currentVisibility);
			} else {
				console.log('No light helpers available');
			}
		};

			function buildLiquid() {

				liquidUniforms = {
					uTime: { value: 0 },
					uTilt: { value: new THREE.Vector2() },
					uRippleCenter: { value: new THREE.Vector2(10000, 10000) },
					uRippleStrength: { value: 0 },
					uFizz: { value: fizzIntensity },
				};

				const surfaceSegments = 64;
				const surfaceGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, surfaceSegments);
				surfaceGeometry.rotateX(-Math.PI * 0.5);
				surfaceGeometry.translate(0, LIQUID_SURFACE_Y - 0.02, 0); // Slightly lower to reduce gap with cylinder

				const surfaceMaterial = new THREE.MeshStandardMaterial({
					color: liquidConfig.surface.color,
					metalness: liquidConfig.surface.metalness,
					roughness: liquidConfig.surface.roughness,
					transparent: liquidConfig.surface.transparent,
					opacity: liquidConfig.surface.opacity,
					emissive: liquidConfig.surface.emissive,
					emissiveIntensity: liquidConfig.surface.emissiveIntensity,
					side: liquidConfig.surface.side === 'Double' ? THREE.DoubleSide : (liquidConfig.surface.side === 'Back' ? THREE.BackSide : THREE.FrontSide),
					depthWrite: liquidConfig.surface.depthWrite,
				});
				if (liquidConfig.surface.envMapIntensity !== undefined) {
					surfaceMaterial.envMapIntensity = liquidConfig.surface.envMapIntensity;
				}

				surfaceMaterial.onBeforeCompile = (shader) => {

					shader.uniforms.uTime = liquidUniforms.uTime;
					shader.uniforms.uTilt = liquidUniforms.uTilt;
					shader.uniforms.uRippleCenter = liquidUniforms.uRippleCenter;
					shader.uniforms.uRippleStrength = liquidUniforms.uRippleStrength;
					shader.uniforms.uFizz = liquidUniforms.uFizz;

					shader.vertexShader = shader.vertexShader.replace(
						'#include <common>',
						`#include <common>
						uniform float uTime;
						uniform vec2 uTilt;
						uniform vec2 uRippleCenter;
						uniform float uRippleStrength;
						uniform float uFizz;
						varying float vWaveHeight;`
					);

					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						`vec3 transformed = vec3(position);
						
						// Tilt effect
						float tilt = dot(transformed.xz, uTilt) * 0.2;
						
						// Gentle waves (slowed down, reduced amplitude)
						float wave = sin(transformed.x * 4.0 + uTime * 0.75) * 0.006
						           + sin(transformed.z * 4.5 + uTime * 0.55) * 0.006
						           + sin((transformed.x + transformed.z) * 3.0 + uTime * 0.9) * 0.004;
						
						// Fizz surface disturbance (slowed down, reduced amplitude)
						float fizz = sin(transformed.x * 20.0 + uTime * 2.5) * 0.0015 * uFizz
						           + sin(transformed.z * 22.0 + uTime * 3.0) * 0.0015 * uFizz;
						
						// Ripple from touch (slowed down)
						float dist = length(transformed.xz - uRippleCenter);
						float ripple = uRippleStrength * exp(-dist * 3.0) * sin(12.0 * dist - uTime * 2.5);
						
						float totalWave = tilt + wave + fizz + ripple;
						transformed.y += totalWave;
						vWaveHeight = totalWave;`
					);

					shader.fragmentShader = shader.fragmentShader.replace(
						'#include <common>',
						`#include <common>
						varying float vWaveHeight;`
					);

					surfaceMaterial.userData.shader = shader;

				};

				liquidSurface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
				liquidSurface.renderOrder = 2;
				scene.add(liquidSurface);

				// Liquid body (tapered - skinnier at bottom, larger at top)
				const bodyGeometry = new THREE.CylinderGeometry(
					LIQUID_RADIUS * liquidConfig.geometry.topRadius,      // Top radius (larger)
					LIQUID_RADIUS * liquidConfig.geometry.bottomRadius,   // Bottom radius (skinnier)
					LIQUID_HEIGHT,
					liquidConfig.geometry.radialSegments,
					liquidConfig.geometry.heightSegments,
					true
				);
				bodyGeometry.translate(0, LIQUID_BASE_Y + LIQUID_HEIGHT * 0.5, 0);

				const bodyMaterial = new THREE.MeshStandardMaterial({
					color: liquidConfig.body.color,
					metalness: liquidConfig.body.metalness,
					roughness: liquidConfig.body.roughness,
					transparent: liquidConfig.body.transparent,
					opacity: liquidConfig.body.opacity,
					emissive: liquidConfig.body.emissive,
					emissiveIntensity: liquidConfig.body.emissiveIntensity,
					side: liquidConfig.body.side === 'Double' ? THREE.DoubleSide : (liquidConfig.body.side === 'Back' ? THREE.BackSide : THREE.FrontSide),
					depthWrite: liquidConfig.body.depthWrite,
				});
				if (liquidConfig.body.envMapIntensity !== undefined) {
					bodyMaterial.envMapIntensity = liquidConfig.body.envMapIntensity;
				}

				liquidBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
				liquidBody.renderOrder = 1;
				scene.add(liquidBody);

				// Liquid bottom (matches bottom radius of tapered cylinder)
				const bottomGeometry = new THREE.CircleGeometry(LIQUID_RADIUS * liquidConfig.geometry.bottomRadius, 64);
				bottomGeometry.rotateX(Math.PI * 0.5);
				bottomGeometry.translate(0, LIQUID_BASE_Y, 0);

				const bottomMaterial = new THREE.MeshStandardMaterial({
					color: liquidConfig.bottom.color,
					metalness: liquidConfig.bottom.metalness,
					roughness: liquidConfig.bottom.roughness,
					transparent: liquidConfig.bottom.transparent,
					opacity: liquidConfig.bottom.opacity,
					emissive: liquidConfig.bottom.emissive,
					emissiveIntensity: liquidConfig.bottom.emissiveIntensity,
					side: liquidConfig.bottom.side === 'Double' ? THREE.DoubleSide : (liquidConfig.bottom.side === 'Back' ? THREE.BackSide : THREE.FrontSide),
					depthWrite: liquidConfig.bottom.depthWrite,
				});

				const liquidBottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
				liquidBottom.renderOrder = 0;
				scene.add(liquidBottom);

				// Invisible raycast plane
				waterPlane = new THREE.Mesh(
					new THREE.PlaneGeometry(LIQUID_RADIUS * 2, LIQUID_RADIUS * 2),
					new THREE.MeshBasicMaterial({ visible: false })
				);
				waterPlane.rotation.x = -Math.PI * 0.5;
				waterPlane.position.y = LIQUID_SURFACE_Y;
				scene.add(waterPlane);

			}

			function setupControls() {

				const fizzSlider = document.getElementById('fizzSlider');
				const fizzValue = document.getElementById('fizzValue');
				const sliceToggle = document.getElementById('sliceToggle');

				const handleFizzChange = () => {

					fizzIntensity = parseFloat(fizzSlider.value) / 100;
					fizzValue.textContent = fizzSlider.value + '%';
					liquidUniforms.uFizz.value = fizzIntensity;

				};

				const handleSliceToggle = () => {

					orangeSliceVisible = !orangeSliceVisible;
					toggleOrangeSlice(orangeSliceVisible);
					sliceToggle.textContent = orangeSliceVisible ? 'Visible' : 'Hidden';
					sliceToggle.classList.toggle('active', orangeSliceVisible);
					sliceToggle.setAttribute('aria-pressed', orangeSliceVisible);

				};

				fizzSlider.addEventListener('input', handleFizzChange);
				sliceToggle.addEventListener('click', handleSliceToggle);

				// Keyboard support
				sliceToggle.addEventListener('keydown', (e) => {

					if (e.key === 'Enter' || e.key === ' ') handleSliceToggle();

				});

			}

			function onPointerMove(event) {

				setMouseFromEvent(event);
				checkHotspotHover();

			}

			function onPointerDown(event) {

				setMouseFromEvent(event);

				// Check hotspot click first
				if (checkHotspotClick()) return;

				triggerRipple();

			}

			function setMouseFromEvent(event) {

				const rect = renderer.domElement.getBoundingClientRect();
				mouse.set(
					((event.clientX - rect.left) / rect.width) * 2 - 1,
					-((event.clientY - rect.top) / rect.height) * 2 + 1
				);

			}

			function triggerRipple() {

				raycaster.setFromCamera(mouse, camera);
				const hit = raycaster.intersectObject(waterPlane);
				if (hit.length === 0) return;

				const point = hit[0].point;
				liquidUniforms.uRippleCenter.value.set(point.x, point.z);
				liquidUniforms.uRippleStrength.value = Math.min(
					liquidUniforms.uRippleStrength.value + 0.4,
					1.2
				);

			}

			function animate() {

				const deltaTime = 1 / 60;
				elapsedTime += deltaTime;

				liquidUniforms.uTime.value += 0.016;
				liquidUniforms.uRippleStrength.value *= 0.95;

			// Update animations
			updateBubbles(deltaTime);
			updateIceAnimation(elapsedTime);
			updateOrangeSliceAnimation(elapsedTime);
			updateHotspots(elapsedTime);

			// Update light helpers
			if (lights) {
				updateLightHelpers(lights);
			}

			controls.update();
			renderer.render(scene, camera);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);

			}

		</script>
	</body>
</html>
