<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - Toki Japanese Highball</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500&family=Cormorant+Garamond:wght@400;500&display=swap');

			body {
				font-family: 'Noto Sans JP', sans-serif;
				background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 50%, #E0F4FF 100%);
			}

			#info {
				background: rgba(20, 40, 60, 0.9);
				border: 1px solid rgba(100, 160, 200, 0.4);
				backdrop-filter: blur(12px);
			}

			#info .title-wrapper span {
				color: #7ec8e8;
				font-family: 'Cormorant Garamond', serif;
				font-weight: 500;
				letter-spacing: 1px;
			}

			#info .title-wrapper a {
				color: #ffffff;
			}

			#info small {
				color: rgba(255, 255, 255, 0.7);
			}

			#drinkControls {
				position: fixed;
				bottom: 20px;
				left: 20px;
				background: rgba(20, 40, 60, 0.92);
				border: 1px solid rgba(100, 160, 200, 0.3);
				border-radius: 16px;
				padding: 20px 24px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 13px;
				backdrop-filter: blur(12px);
				z-index: 100;
				min-width: 220px;
			}

			#drinkControls h3 {
				margin: 0 0 16px 0;
				font-size: 15px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
				font-family: 'Cormorant Garamond', serif;
				text-transform: uppercase;
			}

			.control-row {
				display: flex;
				align-items: center;
				justify-content: space-between;
				margin-bottom: 14px;
			}

			.control-row:last-child {
				margin-bottom: 0;
			}

			.control-row label {
				color: rgba(255, 255, 255, 0.8);
				font-size: 12px;
				min-width: 70px;
			}

			.control-row .controls {
				display: flex;
				align-items: center;
				gap: 8px;
			}

			#drinkControls button {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.4);
				color: #7ec8e8;
				padding: 6px 12px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 12px;
				font-weight: 500;
				transition: all 0.2s ease;
				font-family: inherit;
			}

			#drinkControls button:hover {
				background: rgba(126, 200, 232, 0.25);
				border-color: rgba(126, 200, 232, 0.6);
			}

			#drinkControls button:active {
				transform: scale(0.96);
			}

			#drinkControls button.active {
				background: rgba(126, 200, 232, 0.35);
				border-color: #7ec8e8;
			}

			.qty-btn {
				width: 30px;
				height: 30px;
				padding: 0 !important;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 16px !important;
				font-weight: 600 !important;
				border-radius: 50% !important;
			}

			#iceQuantityValue, #fizzValue {
				min-width: 32px;
				text-align: center;
				font-weight: 500;
				color: #ffffff;
			}

			.slider-control {
				width: 70px;
				height: 4px;
				-webkit-appearance: none;
				appearance: none;
				background: rgba(126, 200, 232, 0.25);
				border-radius: 2px;
				outline: none;
				cursor: pointer;
			}

			.slider-control::-webkit-slider-thumb {
				-webkit-appearance: none;
				appearance: none;
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border-radius: 50%;
				cursor: pointer;
				transition: transform 0.15s ease;
			}

			.slider-control::-webkit-slider-thumb:hover {
				transform: scale(1.15);
			}

			.slider-control::-moz-range-thumb {
				width: 14px;
				height: 14px;
				background: #7ec8e8;
				border: none;
				border-radius: 50%;
				cursor: pointer;
			}

			#brandLabel {
				position: fixed;
				bottom: 20px;
				right: 20px;
				font-family: 'Cormorant Garamond', serif;
				font-size: 24px;
				color: rgba(20, 60, 90, 0.5);
				letter-spacing: 3px;
				text-transform: uppercase;
				writing-mode: vertical-rl;
				text-orientation: mixed;
				z-index: 100;
			}

			/* Hotspot Info Panel Styles */
			.hotspot-panel {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%) scale(0.9);
				background: rgba(20, 40, 60, 0.96);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 20px;
				padding: 32px 40px;
				color: #e8f4fc;
				font-family: 'Noto Sans JP', sans-serif;
				backdrop-filter: blur(16px);
				z-index: 200;
				max-width: 420px;
				width: 90%;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
				box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
			}

			.hotspot-panel.active {
				opacity: 1;
				visibility: visible;
				transform: translate(-50%, -50%) scale(1);
			}

			.hotspot-panel-header {
				display: flex;
				justify-content: space-between;
				align-items: flex-start;
				margin-bottom: 20px;
			}

			.hotspot-panel h2 {
				margin: 0;
				font-family: 'Cormorant Garamond', serif;
				font-size: 26px;
				font-weight: 500;
				color: #7ec8e8;
				letter-spacing: 1px;
			}

			.hotspot-panel-close {
				background: rgba(126, 200, 232, 0.15);
				border: 1px solid rgba(126, 200, 232, 0.3);
				color: #7ec8e8;
				width: 36px;
				height: 36px;
				border-radius: 50%;
				cursor: pointer;
				font-size: 20px;
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.2s ease;
				flex-shrink: 0;
				margin-left: 16px;
			}

			.hotspot-panel-close:hover {
				background: rgba(126, 200, 232, 0.3);
				transform: scale(1.1);
			}

			.hotspot-panel p {
				margin: 0 0 16px 0;
				font-size: 14px;
				line-height: 1.7;
				color: rgba(255, 255, 255, 0.85);
			}

			.hotspot-panel p:last-child {
				margin-bottom: 0;
			}

			.hotspot-panel .highlight {
				color: #dbb85c;
				font-weight: 500;
			}

			.hotspot-panel video {
				width: 100%;
				border-radius: 12px;
				margin-top: 16px;
				background: #000;
			}

			.hotspot-panel .video-placeholder {
				width: 100%;
				aspect-ratio: 16/9;
				background: linear-gradient(135deg, rgba(126, 200, 232, 0.15), rgba(219, 184, 92, 0.15));
				border-radius: 12px;
				margin-top: 16px;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				border: 1px dashed rgba(126, 200, 232, 0.3);
			}

			.hotspot-panel .video-placeholder svg {
				width: 48px;
				height: 48px;
				fill: rgba(126, 200, 232, 0.6);
				margin-bottom: 12px;
			}

			.hotspot-panel .video-placeholder span {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.5);
			}

			.hotspot-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.5);
				z-index: 150;
				opacity: 0;
				visibility: hidden;
				transition: all 0.35s ease;
			}

			.hotspot-overlay.active {
				opacity: 1;
				visibility: visible;
			}

			/* Hotspot Label Tooltips */
			.hotspot-label {
				position: fixed;
				background: rgba(20, 40, 60, 0.9);
				border: 1px solid rgba(126, 200, 232, 0.4);
				border-radius: 8px;
				padding: 8px 14px;
				color: #7ec8e8;
				font-family: 'Noto Sans JP', sans-serif;
				font-size: 12px;
				font-weight: 500;
				pointer-events: none;
				z-index: 120;
				opacity: 0;
				transform: translateY(8px);
				transition: all 0.25s ease;
				white-space: nowrap;
				backdrop-filter: blur(8px);
			}

			.hotspot-label.visible {
				opacity: 1;
				transform: translateY(0);
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a>
				<span>Toki Japanese Highball</span>
			</div>

			<small>
				Tap hotspots to learn more. Drag to orbit.
			</small>
		</div>

		<div id="drinkControls" role="region" aria-label="Drink controls">
			<h3>Highball Settings</h3>
			<div class="control-row">
				<label id="iceLabel">Ice Cubes</label>
				<div class="controls">
					<button id="iceMinus" class="qty-btn" aria-label="Decrease ice" aria-describedby="iceLabel">−</button>
					<span id="iceQuantityValue" aria-live="polite">3</span>
					<button id="icePlus" class="qty-btn" aria-label="Increase ice" aria-describedby="iceLabel">+</button>
				</div>
			</div>
			<div class="control-row">
				<label for="fizzSlider">Carbonation</label>
				<div class="controls">
					<input type="range" id="fizzSlider" class="slider-control" min="0" max="100" step="5" value="70" aria-label="Fizz intensity">
					<span id="fizzValue">70%</span>
				</div>
			</div>
			<div class="control-row">
				<label id="sliceLabel">Orange Slice</label>
				<div class="controls">
					<button id="sliceToggle" aria-pressed="false" aria-describedby="sliceLabel">Hidden</button>
				</div>
			</div>
		</div>

		<div id="brandLabel">TOKI</div>

		<!-- Hotspot Overlay -->
		<div id="hotspotOverlay" class="hotspot-overlay" role="presentation"></div>

		<!-- Hotspot Info Panels -->
		<div id="panelWhisky" class="hotspot-panel" role="dialog" aria-labelledby="panelWhiskyTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelWhiskyTitle">Suntory Toki</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				<span class="highlight">Toki</span> means "time" in Japanese, representing the harmony of old and new. 
				This blended Japanese whisky combines malt from Hakushu and Yamazaki distilleries with 
				grain whisky from Chita.
			</p>
			<p>
				Silky with a subtle sweetness, it's the perfect base for a refreshing Highball—Japan's 
				most popular way to enjoy whisky.
			</p>
		</div>

		<div id="panelIce" class="hotspot-panel" role="dialog" aria-labelledby="panelIceTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelIceTitle">The Perfect Ice</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				In Japan, ice is an art form. Large, <span class="highlight">crystal-clear cubes</span> are essential 
				for the perfect Highball—they melt slowly, keeping your drink cold without over-diluting.
			</p>
			<p>
				The best Highball bars in Tokyo hand-carve their ice from massive blocks, ensuring purity 
				and the ideal melting rate.
			</p>
		</div>

		<div id="panelGlass" class="hotspot-panel" role="dialog" aria-labelledby="panelGlassTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelGlassTitle">Highball Glass</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				The tall, slender <span class="highlight">Collins glass</span> is traditional for Japanese Highballs. 
				Its narrow profile preserves carbonation and creates an elegant presentation.
			</p>
			<p>
				Many Japanese bars freeze their glasses beforehand, creating a frosty exterior that 
				keeps your Highball perfectly chilled from the first sip to the last.
			</p>
		</div>

		<div id="panelVideo" class="hotspot-panel" role="dialog" aria-labelledby="panelVideoTitle" aria-modal="true">
			<div class="hotspot-panel-header">
				<h2 id="panelVideoTitle">The Ritual</h2>
				<button class="hotspot-panel-close" aria-label="Close panel" tabindex="0">×</button>
			</div>
			<p>
				Watch how Japanese bartenders craft the <span class="highlight">perfect Toki Highball</span>—a ritual 
				of precision and care.
			</p>
			<div class="video-placeholder">
				<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
					<path d="M8 5v14l11-7z"/>
				</svg>
				<span>Video content placeholder</span>
			</div>
		</div>

		<!-- Hotspot Label Tooltip -->
		<div id="hotspotLabel" class="hotspot-label"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let renderer, scene, camera, controls;
			let liquidSurface, liquidBody;
			let liquidUniforms;
			let raycaster;
			let waterPlane;
			let glassOuter, glassInner;
			const mouse = new THREE.Vector2();

			// Hotspot system
			const hotspots = [];
			let activePanel = null;
			const hotspotLabel = document.getElementById('hotspotLabel');
			const hotspotOverlay = document.getElementById('hotspotOverlay');

			// Bubble system
			let bubbleGeometry, bubbleMaterial;
			let bubbleInstances = [];
			const MAX_BUBBLES = 500;
			let bubbleMesh;

			// Orange slice
			let orangeSlice;
			let orangeSliceVisible = false;

			// Ice cubes (simple floating objects)
			const iceObjects = [];
			const iceConfig = {
				quantity: 3,
				maxQuantity: 6,
				baseSize: 0.12,
				sizeMultiplier: 3.0,
			};

			// Fizz configuration
			let fizzIntensity = 0.7;

			// Time tracking
			let elapsedTime = 0;

			// Highball glass dimensions (taller and slender)
			const GLASS_RADIUS = 0.85;
			const GLASS_HEIGHT = 2.8;
			const GLASS_THICKNESS = 0.04;

			// Liquid configuration
			const LIQUID_RADIUS = GLASS_RADIUS - GLASS_THICKNESS - 0.02;
			const LIQUID_HEIGHT = 2.2;
			const LIQUID_BASE_Y = 0.1;
			const LIQUID_SURFACE_Y = LIQUID_BASE_Y + LIQUID_HEIGHT;

			// Toki Highball golden amber color
			const LIQUID_COLOR = 0xdbb85c;
			const LIQUID_DEEP_COLOR = 0xc9a040;

			init();

			function createIceMaterial() {

				return new THREE.MeshPhysicalMaterial({
					color: 0xe8eef5,
					metalness: 0.0,
					roughness: 0.15,
					transmission: 0.35,
					opacity: 0.92,
					transparent: true,
					thickness: 1.2,
					clearcoat: 0.6,
					clearcoatRoughness: 0.25,
					ior: 1.31,
					envMapIntensity: 1.2,
					reflectivity: 0.4,
					attenuationColor: new THREE.Color(0xc8d8e8),
					attenuationDistance: 0.25,
					depthWrite: true,
				});

			}

			function createIceMesh(size) {

				// Rectangular ice cube typical for highballs
				const geometry = new THREE.BoxGeometry(size * 1.8, size * 2.2, size * 1.8);
				const material = createIceMaterial();
				const mesh = new THREE.Mesh(geometry, material);
				mesh.renderOrder = 5;
				mesh.userData.baseSize = size;

				return mesh;

			}

			function getCurrentIceSize() {

				return iceConfig.baseSize * iceConfig.sizeMultiplier;

			}

			function updateAllIceSizes() {

				const newSize = getCurrentIceSize();

				for (const ice of iceObjects) {

					const scale = newSize / ice.mesh.userData.baseSize;
					ice.mesh.scale.set(scale, scale, scale);

				}

			}

			function getIceHeight(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Ice height is 2.2 * size * scale
				return size * 2.2 * scale * 0.5;

			}

			function findNonOverlappingPosition(size) {

				const collisionRadiusXZ = size * 1.8 * 0.55;
				const collisionRadiusY = size * 2.2 * 0.5;
				const maxAttempts = 80;
				const boundsRadius = LIQUID_RADIUS - size * 2 - 0.1;
				
				// Base Y position (floating at surface)
				const baseFloatY = LIQUID_SURFACE_Y - size * 0.8;

				for (let attempt = 0; attempt < maxAttempts; attempt++) {

					const angle = Math.random() * Math.PI * 2;
					const radius = Math.random() * boundsRadius;
					const testX = Math.cos(angle) * radius;
					const testZ = Math.sin(angle) * radius;
					let testY = baseFloatY;

					let overlapping = false;
					let maxStackY = baseFloatY;

					// Check against existing ice cubes
					for (const existingIce of iceObjects) {

						const existingRadiusXZ = getIceCollisionRadius(existingIce);
						const existingRadiusY = getIceHeight(existingIce);
						
						const dx = testX - existingIce.baseX;
						const dz = testZ - existingIce.baseZ;
						const distXZ = Math.sqrt(dx * dx + dz * dz);
						const minDistXZ = collisionRadiusXZ + existingRadiusXZ;

						// If horizontally overlapping, check if we need to stack
						if (distXZ < minDistXZ * 0.9) {

							// Calculate the Y position needed to stack on top
							const stackY = existingIce.baseY + existingRadiusY + collisionRadiusY + 0.02;
							maxStackY = Math.max(maxStackY, stackY);

						}

					}

					testY = maxStackY;

					// Verify the stacked position doesn't exceed glass height
					const maxY = LIQUID_SURFACE_Y + 0.6; // Allow some stacking above liquid
					if (testY < maxY) {

						return { x: testX, z: testZ, y: testY };

					}

				}

				// Fallback: return a position anyway, collision system will handle it
				const angle = Math.random() * Math.PI * 2;
				const radius = Math.random() * boundsRadius;
				return { 
					x: Math.cos(angle) * radius, 
					z: Math.sin(angle) * radius, 
					y: baseFloatY 
				};

			}

			function spawnIce() {

				if (iceObjects.length >= iceConfig.maxQuantity) return;

				const size = getCurrentIceSize();
				const position = findNonOverlappingPosition(size);

				const mesh = createIceMesh(size);

				// Each ice cube gets unique animation parameters
				const iceData = {
					mesh,
					baseX: position.x,
					baseY: position.y,
					baseZ: position.z,
					velocityY: 0,
					phaseX: Math.random() * Math.PI * 2,
					phaseZ: Math.random() * Math.PI * 2,
					phaseY: Math.random() * Math.PI * 2,
					rotationSpeed: (Math.random() - 0.5) * 0.3,
					bobSpeed: 0.8 + Math.random() * 0.4,
					bobAmount: 0.01 + Math.random() * 0.008,
					driftAmount: 0.015 + Math.random() * 0.015,
				};

				mesh.position.set(
					iceData.baseX,
					iceData.baseY,
					iceData.baseZ
				);

				mesh.rotation.set(
					Math.random() * 0.3,
					Math.random() * Math.PI * 2,
					Math.random() * 0.3
				);

				scene.add(mesh);
				iceObjects.push(iceData);

			}

			function removeIce() {

				if (iceObjects.length === 0) return;

				const ice = iceObjects.pop();
				scene.remove(ice.mesh);
				ice.mesh.geometry.dispose();
				ice.mesh.material.dispose();

			}

			function setIceQuantity(quantity) {

				const targetQuantity = Math.max(0, Math.min(quantity, iceConfig.maxQuantity));
				iceConfig.quantity = targetQuantity;

				while (iceObjects.length < targetQuantity) {

					spawnIce();

				}

				while (iceObjects.length > targetQuantity) {

					removeIce();

				}

				updateQuantityDisplay();

			}

			function updateQuantityDisplay() {

				const quantityValue = document.getElementById('iceQuantityValue');
				if (quantityValue) {

					quantityValue.textContent = iceObjects.length;

				}

			}

			function getIceCollisionRadius(ice) {

				const size = getCurrentIceSize();
				const scale = ice.mesh.scale.x;
				// Use the larger dimension (1.8 * size * scale) as collision radius
				return size * 1.8 * scale * 0.5;

			}

			function resolveIceCollisions() {

				const repulsionStrength = 0.08;
				const minDistance = 0.01;
				const size = getCurrentIceSize();
				const baseFloatY = LIQUID_SURFACE_Y - size * 0.8;

				for (let i = 0; i < iceObjects.length; i++) {

					const iceA = iceObjects[i];
					const radiusA = getIceCollisionRadius(iceA);
					const heightA = getIceHeight(iceA);

					for (let j = i + 1; j < iceObjects.length; j++) {

						const iceB = iceObjects[j];
						const radiusB = getIceCollisionRadius(iceB);
						const heightB = getIceHeight(iceB);

						const dx = iceB.baseX - iceA.baseX;
						const dy = iceB.baseY - iceA.baseY;
						const dz = iceB.baseZ - iceA.baseZ;
						
						const distXZ = Math.sqrt(dx * dx + dz * dz);
						const minDistXZ = radiusA + radiusB;
						const minDistY = heightA + heightB;

						// Check if cubes overlap in XZ plane
						const overlapXZ = minDistXZ - distXZ;
						const overlapY = minDistY - Math.abs(dy);

						// Only process if there's actual 3D overlap
						if (overlapXZ > 0 && overlapY > 0) {

							// Determine if we should push horizontally or vertically
							// Push in the direction of least resistance
							if (overlapXZ < overlapY && distXZ > minDistance) {

								// Push horizontally
								const pushX = (dx / distXZ) * overlapXZ * 0.5 * repulsionStrength;
								const pushZ = (dz / distXZ) * overlapXZ * 0.5 * repulsionStrength;

								iceA.baseX -= pushX;
								iceA.baseZ -= pushZ;
								iceB.baseX += pushX;
								iceB.baseZ += pushZ;

							} else {

								// Push vertically (stack)
								const pushY = overlapY * 0.5 * repulsionStrength;
								
								if (iceA.baseY < iceB.baseY) {

									// A is below B, push B up
									iceB.baseY += pushY;
									iceA.baseY -= pushY * 0.3;

								} else {

									// B is below A, push A up
									iceA.baseY += pushY;
									iceB.baseY -= pushY * 0.3;

								}

							}

						}

					}

					// Apply buoyancy - ice wants to float at surface level
					const buoyancyTarget = baseFloatY;
					const buoyancyStrength = 0.02;
					
					if (iceA.baseY < buoyancyTarget) {

						iceA.baseY += (buoyancyTarget - iceA.baseY) * buoyancyStrength;

					}

					// Keep within glass bounds after collision resolution
					const boundsRadius = LIQUID_RADIUS - size * 1.5 - 0.05;
					const currentDist = Math.sqrt(iceA.baseX * iceA.baseX + iceA.baseZ * iceA.baseZ);

					if (currentDist > boundsRadius) {

						const scaleXZ = boundsRadius / currentDist;
						iceA.baseX *= scaleXZ;
						iceA.baseZ *= scaleXZ;

					}

					// Cap maximum height
					const maxY = LIQUID_SURFACE_Y + 0.8;
					if (iceA.baseY > maxY) {

						iceA.baseY = maxY;

					}

				}

			}

			function updateIceAnimation(time) {

				const size = getCurrentIceSize();

				// Resolve collisions multiple times per frame for stability
				for (let iter = 0; iter < 3; iter++) {

					resolveIceCollisions();

				}

				for (const ice of iceObjects) {

					// Gentle bobbing motion (reduced for stacked ice)
					const bobY = Math.sin(time * ice.bobSpeed + ice.phaseY) * ice.bobAmount;

					// Slight drift in X and Z (reduced to let collision handle positioning)
					const driftX = Math.sin(time * 0.3 + ice.phaseX) * ice.driftAmount;
					const driftZ = Math.cos(time * 0.25 + ice.phaseZ) * ice.driftAmount;

					// Apply position from base + drift
					let newX = ice.baseX + driftX;
					let newZ = ice.baseZ + driftZ;

					// Final boundary check
					const dist = Math.sqrt(newX * newX + newZ * newZ);
					const maxDist = LIQUID_RADIUS - size * 1.5 - 0.05;

					if (dist > maxDist) {

						const boundsScale = maxDist / dist;
						newX *= boundsScale;
						newZ *= boundsScale;

					}

					ice.mesh.position.x = newX;
					ice.mesh.position.y = ice.baseY + bobY;
					ice.mesh.position.z = newZ;

					// Gentle rotation
					ice.mesh.rotation.y += ice.rotationSpeed * 0.016;
					ice.mesh.rotation.x = Math.sin(time * 0.5 + ice.phaseX) * 0.08;
					ice.mesh.rotation.z = Math.cos(time * 0.4 + ice.phaseZ) * 0.08;

				}

			}

			// Orange slice creation
			function createOrangeSlice() {

				const group = new THREE.Group();

				const sliceRadius = 0.35;
				const sliceThickness = 0.08;

				// Orange flesh
				const fleshGeometry = new THREE.CylinderGeometry(
					sliceRadius,
					sliceRadius,
					sliceThickness,
					32,
					1,
					false,
					0,
					Math.PI
				);
				const fleshMaterial = new THREE.MeshStandardMaterial({
					color: 0xff9f43,
					metalness: 0.0,
					roughness: 0.6,
					transparent: true,
					opacity: 0.95,
				});
				const flesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
				flesh.rotation.z = Math.PI / 2;
				group.add(flesh);

				// Orange rind (outer edge)
				const rindGeometry = new THREE.TorusGeometry(
					sliceRadius,
					sliceThickness * 0.6,
					8,
					16,
					Math.PI
				);
				const rindMaterial = new THREE.MeshStandardMaterial({
					color: 0xff6b35,
					metalness: 0.0,
					roughness: 0.7,
				});
				const rind = new THREE.Mesh(rindGeometry, rindMaterial);
				rind.rotation.x = Math.PI / 2;
				rind.position.y = 0;
				group.add(rind);

				// Segment lines on the flesh
				const segmentCount = 8;
				const segmentMaterial = new THREE.MeshStandardMaterial({
					color: 0xffeaa7,
					metalness: 0.0,
					roughness: 0.8,
				});

				for (let i = 1; i < segmentCount; i++) {

					const angle = (i / segmentCount) * Math.PI;
					const lineGeometry = new THREE.BoxGeometry(
						sliceRadius * 0.9,
						sliceThickness * 0.3,
						0.01
					);
					const line = new THREE.Mesh(lineGeometry, segmentMaterial);

					line.position.x = Math.cos(angle) * sliceRadius * 0.45;
					line.position.z = Math.sin(angle) * sliceRadius * 0.45;
					line.rotation.y = -angle + Math.PI / 2;

					group.add(line);

				}

				// Center pith
				const pithGeometry = new THREE.CylinderGeometry(
					sliceRadius * 0.15,
					sliceRadius * 0.15,
					sliceThickness * 1.1,
					16
				);
				const pithMaterial = new THREE.MeshStandardMaterial({
					color: 0xffeaa7,
					metalness: 0.0,
					roughness: 0.9,
				});
				const pith = new THREE.Mesh(pithGeometry, pithMaterial);
				pith.rotation.z = Math.PI / 2;
				group.add(pith);

				group.rotation.x = Math.PI * 0.15;
				group.rotation.z = Math.PI * 0.1;

				return group;

			}

			function spawnOrangeSlice() {

				orangeSlice = createOrangeSlice();
				orangeSlice.position.set(0.25, LIQUID_SURFACE_Y + 0.02, 0.15);
				orangeSlice.renderOrder = 6;
				orangeSlice.visible = orangeSliceVisible;
				scene.add(orangeSlice);

			}

			function updateOrangeSliceAnimation(time) {

				if (!orangeSlice || !orangeSliceVisible) return;

				// Gentle floating motion
				const bobY = Math.sin(time * 0.7) * 0.01;
				const driftX = Math.sin(time * 0.2) * 0.03;
				const driftZ = Math.cos(time * 0.18) * 0.03;

				orangeSlice.position.y = LIQUID_SURFACE_Y + 0.02 + bobY;
				orangeSlice.position.x = 0.25 + driftX;
				orangeSlice.position.z = 0.15 + driftZ;

				// Gentle rotation
				orangeSlice.rotation.y = Math.sin(time * 0.15) * 0.2;

			}

			function toggleOrangeSlice(visible) {

				orangeSliceVisible = visible;

				if (orangeSlice) {

					orangeSlice.visible = visible;

				}

			}

			// Hotspot creation
			function createHotspot(position, label, panelId, color = 0x7ec8e8) {

				const group = new THREE.Group();
				group.position.copy(position);

				// Inner pulsing dot
				const dotGeometry = new THREE.SphereGeometry(0.06, 16, 16);
				const dotMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.9,
				});
				const dot = new THREE.Mesh(dotGeometry, dotMaterial);
				group.add(dot);

				// Outer ring
				const ringGeometry = new THREE.RingGeometry(0.1, 0.14, 32);
				const ringMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.6,
					side: THREE.DoubleSide,
				});
				const ring = new THREE.Mesh(ringGeometry, ringMaterial);
				ring.lookAt(camera.position);
				group.add(ring);

				// Pulse ring (animated)
				const pulseGeometry = new THREE.RingGeometry(0.08, 0.1, 32);
				const pulseMaterial = new THREE.MeshBasicMaterial({
					color: color,
					transparent: true,
					opacity: 0.5,
					side: THREE.DoubleSide,
				});
				const pulseRing = new THREE.Mesh(pulseGeometry, pulseMaterial);
				pulseRing.lookAt(camera.position);
				group.add(pulseRing);

				group.userData = {
					label: label,
					panelId: panelId,
					dot: dot,
					ring: ring,
					pulseRing: pulseRing,
					baseScale: 1,
					hovered: false,
				};

				scene.add(group);
				hotspots.push(group);

				return group;

			}

			function initHotspots() {

				// Whisky hotspot - at the liquid level
				createHotspot(
					new THREE.Vector3(0.9, 1.5, 0.4),
					'About Toki Whisky',
					'panelWhisky',
					0xdbb85c
				);

				// Ice hotspot - near the ice cubes
				createHotspot(
					new THREE.Vector3(-0.5, 2.2, 0.7),
					'The Perfect Ice',
					'panelIce',
					0xaaddff
				);

				// Glass hotspot - on the glass rim
				createHotspot(
					new THREE.Vector3(0.6, 2.8, -0.5),
					'Highball Glass',
					'panelGlass',
					0x7ec8e8
				);

				// Video hotspot - near the base
				createHotspot(
					new THREE.Vector3(-0.8, 0.6, -0.6),
					'Watch the Ritual',
					'panelVideo',
					0xff9f43
				);

			}

			function updateHotspots(time) {

				for (const hotspot of hotspots) {

					const { ring, pulseRing, hovered } = hotspot.userData;

					// Make rings face camera
					ring.lookAt(camera.position);
					pulseRing.lookAt(camera.position);

					// Pulse animation
					const pulse = 1 + Math.sin(time * 3) * 0.15;
					pulseRing.scale.set(pulse, pulse, pulse);
					pulseRing.material.opacity = 0.5 * (1 - (pulse - 1) / 0.15 * 0.5);

					// Hover effect
					const targetScale = hovered ? 1.3 : 1;
					hotspot.userData.baseScale += (targetScale - hotspot.userData.baseScale) * 0.1;
					hotspot.scale.setScalar(hotspot.userData.baseScale);

				}

			}

			function checkHotspotHover() {

				raycaster.setFromCamera(mouse, camera);

				let foundHover = false;

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						hotspot.userData.hovered = true;
						foundHover = true;

						// Show label
						const screenPos = hotspot.position.clone().project(camera);
						const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
						const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

						hotspotLabel.textContent = hotspot.userData.label;
						hotspotLabel.style.left = x + 'px';
						hotspotLabel.style.top = (y - 50) + 'px';
						hotspotLabel.classList.add('visible');

						renderer.domElement.style.cursor = 'pointer';

					} else {

						hotspot.userData.hovered = false;

					}

				}

				if (!foundHover) {

					hotspotLabel.classList.remove('visible');
					renderer.domElement.style.cursor = 'grab';

				}

			}

			function checkHotspotClick() {

				raycaster.setFromCamera(mouse, camera);

				for (const hotspot of hotspots) {

					const intersects = raycaster.intersectObject(hotspot, true);

					if (intersects.length > 0 && intersects[0].distance < 10) {

						openPanel(hotspot.userData.panelId);
						return true;

					}

				}

				return false;

			}

			function openPanel(panelId) {

				// Close any open panel first
				closePanel();

				const panel = document.getElementById(panelId);
				if (panel) {

					activePanel = panel;
					panel.classList.add('active');
					hotspotOverlay.classList.add('active');
					hotspotLabel.classList.remove('visible');

					// Focus trap for accessibility
					const closeBtn = panel.querySelector('.hotspot-panel-close');
					if (closeBtn) closeBtn.focus();

				}

			}

			function closePanel() {

				if (activePanel) {

					activePanel.classList.remove('active');
					activePanel = null;

				}

				hotspotOverlay.classList.remove('active');

			}

			function setupPanelControls() {

				// Close buttons
				document.querySelectorAll('.hotspot-panel-close').forEach(btn => {

					btn.addEventListener('click', closePanel);
					btn.addEventListener('keydown', (e) => {

						if (e.key === 'Enter' || e.key === ' ') {

							e.preventDefault();
							closePanel();

						}

					});

				});

				// Overlay click to close
				hotspotOverlay.addEventListener('click', closePanel);

				// Escape key to close
				document.addEventListener('keydown', (e) => {

					if (e.key === 'Escape' && activePanel) {

						closePanel();

					}

				});

			}

			// Bubble system
			function initBubbleSystem() {

				bubbleGeometry = new THREE.SphereGeometry(0.015, 8, 8);
				bubbleMaterial = new THREE.MeshStandardMaterial({
					color: 0xffffff,
					metalness: 0.0,
					roughness: 0.2,
					transparent: true,
					opacity: 0.6,
					emissive: 0xffeedd,
					emissiveIntensity: 0.1,
				});

				bubbleMesh = new THREE.InstancedMesh(bubbleGeometry, bubbleMaterial, MAX_BUBBLES);
				bubbleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
				bubbleMesh.renderOrder = 4;
				scene.add(bubbleMesh);

				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleInstances.push({
						active: false,
						position: new THREE.Vector3(),
						velocity: new THREE.Vector3(),
						size: 1,
						life: 0,
						maxLife: 0,
					});

				}

				const matrix = new THREE.Matrix4();
				matrix.makeScale(0, 0, 0);
				for (let i = 0; i < MAX_BUBBLES; i++) {

					bubbleMesh.setMatrixAt(i, matrix);

				}
				bubbleMesh.instanceMatrix.needsUpdate = true;

			}

			function spawnBubble() {

				const bubble = bubbleInstances.find(b => !b.active);
				if (!bubble) return;

				const angle = Math.random() * Math.PI * 2;
				const radius = Math.random() * (LIQUID_RADIUS - 0.1);

				bubble.position.set(
					Math.cos(angle) * radius,
					LIQUID_BASE_Y + 0.05,
					Math.sin(angle) * radius
				);

				bubble.velocity.set(
					(Math.random() - 0.5) * 0.02,
					0.3 + Math.random() * 0.4,
					(Math.random() - 0.5) * 0.02
				);

				bubble.size = 0.5 + Math.random() * 1.0;
				bubble.life = 0;
				bubble.maxLife = 2 + Math.random() * 3;
				bubble.active = true;

			}

			function updateBubbles(deltaTime) {

				const spawnRate = fizzIntensity * 30;
				const spawnChance = spawnRate * deltaTime;

				if (Math.random() < spawnChance) {

					spawnBubble();

				}

				const matrix = new THREE.Matrix4();
				const position = new THREE.Vector3();
				const quaternion = new THREE.Quaternion();
				const scale = new THREE.Vector3();

				for (let i = 0; i < bubbleInstances.length; i++) {

					const bubble = bubbleInstances[i];

					if (!bubble.active) {

						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					bubble.life += deltaTime;

					if (bubble.life > bubble.maxLife || bubble.position.y > LIQUID_SURFACE_Y) {

						bubble.active = false;
						scale.set(0, 0, 0);
						matrix.compose(bubble.position, quaternion, scale);
						bubbleMesh.setMatrixAt(i, matrix);
						continue;

					}

					// Add slight wobble
					bubble.velocity.x += (Math.random() - 0.5) * 0.05;
					bubble.velocity.z += (Math.random() - 0.5) * 0.05;

					bubble.position.x += bubble.velocity.x * deltaTime;
					bubble.position.y += bubble.velocity.y * deltaTime;
					bubble.position.z += bubble.velocity.z * deltaTime;

					const dist = Math.sqrt(
						bubble.position.x * bubble.position.x +
						bubble.position.z * bubble.position.z
					);

					if (dist > LIQUID_RADIUS - 0.05) {

						bubble.position.x *= (LIQUID_RADIUS - 0.05) / dist;
						bubble.position.z *= (LIQUID_RADIUS - 0.05) / dist;

					}

					const lifeRatio = bubble.life / bubble.maxLife;
					let sizeMultiplier = 1;

					if (lifeRatio < 0.1) {

						sizeMultiplier = lifeRatio / 0.1;

					} else if (lifeRatio > 0.9) {

						sizeMultiplier = (1 - lifeRatio) / 0.1;

					}

					const finalSize = bubble.size * sizeMultiplier;
					scale.set(finalSize, finalSize, finalSize);
					matrix.compose(bubble.position, quaternion, scale);
					bubbleMesh.setMatrixAt(i, matrix);

				}

				bubbleMesh.instanceMatrix.needsUpdate = true;

			}

			function init() {

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputColorSpace = THREE.SRGBColorSpace;
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.1;
				document.body.appendChild(renderer.domElement);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x87CEEB);

				// Create simple environment for reflections on ice
				const pmremGenerator = new THREE.PMREMGenerator(renderer);
				const envScene = new THREE.Scene();
				envScene.background = new THREE.Color(0xaaddff);
				
				// Add gradient sphere for soft environment lighting
				const envGeo = new THREE.SphereGeometry(50, 32, 32);
				const envMat = new THREE.MeshBasicMaterial({
					color: 0xeef6ff,
					side: THREE.BackSide,
				});
				const envMesh = new THREE.Mesh(envGeo, envMat);
				envScene.add(envMesh);
				
				const envMap = pmremGenerator.fromScene(envScene).texture;
				scene.environment = envMap;
				pmremGenerator.dispose();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
				// Start zoomed out to max distance
				camera.position.set(0, 3.5, 8);
				camera.lookAt(0, 1.2, 0);

				// Bright ambient lighting for light scene
				const ambient = new THREE.AmbientLight(0xffffff, 1.0);
				scene.add(ambient);

				const hemi = new THREE.HemisphereLight(0x87CEEB, 0xffffff, 0.8);
				scene.add(hemi);

				// Key light (bright white/warm)
				const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
				keyLight.position.set(3, 5, 2);
				scene.add(keyLight);

				// Fill light (soft blue from sky)
				const fillLight = new THREE.DirectionalLight(0xaaddff, 1.2);
				fillLight.position.set(-3, 3, -2);
				scene.add(fillLight);

				// Rim light (warm accent)
				const rimLight = new THREE.DirectionalLight(0xffeedd, 1.0);
				rimLight.position.set(0, 2, -4);
				scene.add(rimLight);

				// Bar surface - rich wood brown
				const barGeometry = new THREE.CylinderGeometry(8, 8, 0.3, 64);
				const barMaterial = new THREE.MeshStandardMaterial({
					color: 0x5c3d2e,
					roughness: 0.6,
					metalness: 0.1,
				});
				const bar = new THREE.Mesh(barGeometry, barMaterial);
				bar.position.y = -0.15;
				scene.add(bar);

				buildLiquid();
				buildGlass();
				initBubbleSystem();

				// Spawn initial ice
				for (let i = 0; i < iceConfig.quantity; i++) {

					spawnIce();

				}

				// Spawn orange slice
				spawnOrangeSlice();

				// Initialize hotspots
				initHotspots();

				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
				controls.target.set(0, 1.2, 0);
				controls.minDistance = 2.5;
				controls.maxDistance = 8;
				controls.maxPolarAngle = Math.PI * 0.85;

				raycaster = new THREE.Raycaster();
				renderer.domElement.addEventListener('pointermove', onPointerMove);
				renderer.domElement.addEventListener('pointerdown', onPointerDown);

				window.addEventListener('resize', onWindowResize);

				setupControls();
				setupPanelControls();

				renderer.setAnimationLoop(animate);

			}

			function buildGlass() {

				// Outer glass cylinder
				const outerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS,
					GLASS_RADIUS * 0.92,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialOuter = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 0.97,
					opacity: 1,
					transparent: true,
					thickness: 0.08,
					clearcoat: 1.0,
					ior: 1.52,
					envMapIntensity: 1.2,
					depthWrite: false,
				});

				glassOuter = new THREE.Mesh(outerGeometry, glassMaterialOuter);
				glassOuter.position.y = GLASS_HEIGHT / 2 + 0.1;
				glassOuter.renderOrder = 10;
				scene.add(glassOuter);

				// Inner glass surface
				const innerGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS - GLASS_THICKNESS,
					(GLASS_RADIUS * 0.92) - GLASS_THICKNESS,
					GLASS_HEIGHT,
					64,
					1,
					true
				);

				const glassMaterialInner = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.02,
					transmission: 0.97,
					opacity: 1,
					transparent: true,
					thickness: 0.08,
					clearcoat: 1.0,
					ior: 1.52,
					side: THREE.BackSide,
					depthWrite: false,
				});

				glassInner = new THREE.Mesh(innerGeometry, glassMaterialInner);
				glassInner.position.y = GLASS_HEIGHT / 2 + 0.1;
				glassInner.renderOrder = 9;
				scene.add(glassInner);

				// Glass bottom
				const bottomGeometry = new THREE.CylinderGeometry(
					GLASS_RADIUS * 0.92,
					GLASS_RADIUS * 0.92,
					0.12,
					64
				);
				const bottomMaterial = new THREE.MeshPhysicalMaterial({
					color: 0xffffff,
					metalness: 0,
					roughness: 0.05,
					transmission: 0.9,
					transparent: true,
					thickness: 0.12,
					ior: 1.52,
					depthWrite: false,
				});

				const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
				bottom.position.y = 0.06;
				bottom.renderOrder = 8;
				scene.add(bottom);

			}

			function buildLiquid() {

				liquidUniforms = {
					uTime: { value: 0 },
					uTilt: { value: new THREE.Vector2() },
					uRippleCenter: { value: new THREE.Vector2(10000, 10000) },
					uRippleStrength: { value: 0 },
					uFizz: { value: fizzIntensity },
				};

				const surfaceSegments = 64;
				const surfaceGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, surfaceSegments);
				surfaceGeometry.rotateX(-Math.PI * 0.5);
				surfaceGeometry.translate(0, LIQUID_SURFACE_Y, 0);

				const surfaceMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_COLOR,
					metalness: 0.15,
					roughness: 0.08,
					transparent: true,
					opacity: 0.88,
					emissive: LIQUID_DEEP_COLOR,
					emissiveIntensity: 0.08,
					side: THREE.DoubleSide,
					depthWrite: true,
				});

				surfaceMaterial.onBeforeCompile = (shader) => {

					shader.uniforms.uTime = liquidUniforms.uTime;
					shader.uniforms.uTilt = liquidUniforms.uTilt;
					shader.uniforms.uRippleCenter = liquidUniforms.uRippleCenter;
					shader.uniforms.uRippleStrength = liquidUniforms.uRippleStrength;
					shader.uniforms.uFizz = liquidUniforms.uFizz;

					shader.vertexShader = shader.vertexShader.replace(
						'#include <common>',
						`#include <common>
						uniform float uTime;
						uniform vec2 uTilt;
						uniform vec2 uRippleCenter;
						uniform float uRippleStrength;
						uniform float uFizz;
						varying float vWaveHeight;`
					);

					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						`vec3 transformed = vec3(position);
						
						// Tilt effect
						float tilt = dot(transformed.xz, uTilt) * 0.2;
						
						// Gentle waves
						float wave = sin(transformed.x * 4.0 + uTime * 1.5) * 0.012
						           + sin(transformed.z * 4.5 + uTime * 1.1) * 0.012
						           + sin((transformed.x + transformed.z) * 3.0 + uTime * 1.8) * 0.008;
						
						// Fizz surface disturbance
						float fizz = sin(transformed.x * 20.0 + uTime * 5.0) * 0.003 * uFizz
						           + sin(transformed.z * 22.0 + uTime * 6.0) * 0.003 * uFizz;
						
						// Ripple from touch
						float dist = length(transformed.xz - uRippleCenter);
						float ripple = uRippleStrength * exp(-dist * 3.0) * sin(12.0 * dist - uTime * 5.0);
						
						float totalWave = tilt + wave + fizz + ripple;
						transformed.y += totalWave;
						vWaveHeight = totalWave;`
					);

					shader.fragmentShader = shader.fragmentShader.replace(
						'#include <common>',
						`#include <common>
						varying float vWaveHeight;`
					);

					surfaceMaterial.userData.shader = shader;

				};

				liquidSurface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
				liquidSurface.renderOrder = 2;
				scene.add(liquidSurface);

				// Liquid body (cylinder)
				const bodyGeometry = new THREE.CylinderGeometry(
					LIQUID_RADIUS,
					LIQUID_RADIUS,
					LIQUID_HEIGHT,
					64,
					1,
					true
				);
				bodyGeometry.translate(0, LIQUID_BASE_Y + LIQUID_HEIGHT * 0.5, 0);

				const bodyMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_COLOR,
					metalness: 0.1,
					roughness: 0.12,
					transparent: true,
					opacity: 0.75,
					emissive: LIQUID_DEEP_COLOR,
					emissiveIntensity: 0.05,
					side: THREE.DoubleSide,
					depthWrite: false,
				});

				liquidBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
				liquidBody.renderOrder = 1;
				scene.add(liquidBody);

				// Liquid bottom
				const bottomGeometry = new THREE.CircleGeometry(LIQUID_RADIUS, 64);
				bottomGeometry.rotateX(Math.PI * 0.5);
				bottomGeometry.translate(0, LIQUID_BASE_Y, 0);

				const bottomMaterial = new THREE.MeshStandardMaterial({
					color: LIQUID_DEEP_COLOR,
					metalness: 0.1,
					roughness: 0.2,
					transparent: true,
					opacity: 0.7,
					emissive: 0x8b6914,
					emissiveIntensity: 0.03,
					side: THREE.DoubleSide,
					depthWrite: false,
				});

				const liquidBottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
				liquidBottom.renderOrder = 0;
				scene.add(liquidBottom);

				// Invisible raycast plane
				waterPlane = new THREE.Mesh(
					new THREE.PlaneGeometry(LIQUID_RADIUS * 2, LIQUID_RADIUS * 2),
					new THREE.MeshBasicMaterial({ visible: false })
				);
				waterPlane.rotation.x = -Math.PI * 0.5;
				waterPlane.position.y = LIQUID_SURFACE_Y;
				scene.add(waterPlane);

			}

			function setupControls() {

				const iceMinus = document.getElementById('iceMinus');
				const icePlus = document.getElementById('icePlus');
				const fizzSlider = document.getElementById('fizzSlider');
				const fizzValue = document.getElementById('fizzValue');
				const sliceToggle = document.getElementById('sliceToggle');

				const handleIceMinus = () => {

					setIceQuantity(iceConfig.quantity - 1);

				};

				const handleIcePlus = () => {

					setIceQuantity(iceConfig.quantity + 1);

				};

				const handleFizzChange = () => {

					fizzIntensity = parseFloat(fizzSlider.value) / 100;
					fizzValue.textContent = fizzSlider.value + '%';
					liquidUniforms.uFizz.value = fizzIntensity;

				};

				const handleSliceToggle = () => {

					orangeSliceVisible = !orangeSliceVisible;
					toggleOrangeSlice(orangeSliceVisible);
					sliceToggle.textContent = orangeSliceVisible ? 'Visible' : 'Hidden';
					sliceToggle.classList.toggle('active', orangeSliceVisible);
					sliceToggle.setAttribute('aria-pressed', orangeSliceVisible);

				};

				iceMinus.addEventListener('click', handleIceMinus);
				icePlus.addEventListener('click', handleIcePlus);
				fizzSlider.addEventListener('input', handleFizzChange);
				sliceToggle.addEventListener('click', handleSliceToggle);

				// Keyboard support
				iceMinus.addEventListener('keydown', (e) => {

					if (e.key === 'Enter' || e.key === ' ') handleIceMinus();

				});
				icePlus.addEventListener('keydown', (e) => {

					if (e.key === 'Enter' || e.key === ' ') handleIcePlus();

				});
				sliceToggle.addEventListener('keydown', (e) => {

					if (e.key === 'Enter' || e.key === ' ') handleSliceToggle();

				});

			}

			function onPointerMove(event) {

				setMouseFromEvent(event);
				checkHotspotHover();

			}

			function onPointerDown(event) {

				setMouseFromEvent(event);

				// Check hotspot click first
				if (checkHotspotClick()) return;

				triggerRipple();

			}

			function setMouseFromEvent(event) {

				const rect = renderer.domElement.getBoundingClientRect();
				mouse.set(
					((event.clientX - rect.left) / rect.width) * 2 - 1,
					-((event.clientY - rect.top) / rect.height) * 2 + 1
				);

			}

			function triggerRipple() {

				raycaster.setFromCamera(mouse, camera);
				const hit = raycaster.intersectObject(waterPlane);
				if (hit.length === 0) return;

				const point = hit[0].point;
				liquidUniforms.uRippleCenter.value.set(point.x, point.z);
				liquidUniforms.uRippleStrength.value = Math.min(
					liquidUniforms.uRippleStrength.value + 0.4,
					1.2
				);

			}

			function animate() {

				const deltaTime = 1 / 60;
				elapsedTime += deltaTime;

				liquidUniforms.uTime.value += 0.016;
				liquidUniforms.uRippleStrength.value *= 0.95;

				// Update animations
				updateBubbles(deltaTime);
				updateIceAnimation(elapsedTime);
				updateOrangeSliceAnimation(elapsedTime);
				updateHotspots(elapsedTime);

				controls.update();
				renderer.render(scene, camera);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);

			}

		</script>
	</body>
</html>
